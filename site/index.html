<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>RxScala</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">
         
        <header>
          <h1>RxScala</h1>
          <h2></h2>
        </header>

         <h2 id='note_work_on_this_page_is_in_progress'>NOTE: Work on this page is in progress&#8230;</h2>

<h2 id='readme'>README</h2>

<p>Allows to use RxJava in Scala with anonymous functions, e.g.</p>
<div class='highlight'><pre><code class='scala'><span class='k'>val</span> <span class='n'>o</span> <span class='k'>=</span> <span class='nc'>Observable</span><span class='o'>.</span><span class='n'>interval</span><span class='o'>(</span><span class='mi'>200</span> <span class='n'>millis</span><span class='o'>).</span><span class='n'>take</span><span class='o'>(</span><span class='mi'>5</span><span class='o'>)</span>
<span class='n'>o</span><span class='o'>.</span><span class='n'>subscribe</span><span class='o'>(</span><span class='n'>n</span> <span class='k'>=&gt;</span> <span class='n'>println</span><span class='o'>(</span><span class='s'>&quot;n = &quot;</span> <span class='o'>+</span> <span class='n'>n</span><span class='o'>))</span>
<span class='nc'>Observable</span><span class='o'>(</span><span class='mi'>1</span><span class='o'>,</span> <span class='mi'>2</span><span class='o'>,</span> <span class='mi'>3</span><span class='o'>,</span> <span class='mi'>4</span><span class='o'>).</span><span class='n'>reduce</span><span class='o'>(</span><span class='k'>_</span> <span class='o'>+</span> <span class='k'>_</span><span class='o'>)</span>
</code></pre></div>
<p>For-comprehensions are also supported:</p>
<div class='highlight'><pre><code class='scala'><span class='k'>val</span> <span class='n'>first</span> <span class='k'>=</span> <span class='nc'>Observable</span><span class='o'>(</span><span class='mi'>10</span><span class='o'>,</span> <span class='mi'>11</span><span class='o'>,</span> <span class='mi'>12</span><span class='o'>)</span>
<span class='k'>val</span> <span class='n'>second</span> <span class='k'>=</span> <span class='nc'>Observable</span><span class='o'>(</span><span class='mi'>10</span><span class='o'>,</span> <span class='mi'>11</span><span class='o'>,</span> <span class='mi'>12</span><span class='o'>)</span>
<span class='k'>val</span> <span class='n'>booleans</span> <span class='k'>=</span> <span class='k'>for</span> <span class='o'>((</span><span class='n'>n1</span><span class='o'>,</span> <span class='n'>n2</span><span class='o'>)</span> <span class='k'>&lt;-</span> <span class='o'>(</span><span class='n'>first</span> <span class='n'>zip</span> <span class='n'>second</span><span class='o'>))</span> <span class='k'>yield</span> <span class='o'>(</span><span class='n'>n1</span> <span class='o'>==</span> <span class='n'>n2</span><span class='o'>)</span>
</code></pre></div>
<p>This adaptor attempts to expose an API which is as Scala-idiomatic as possible. This means that certain methods have been renamed, their signature was changed, or static methods were changed to instance methods. Some examples:</p>
<div class='highlight'><pre><code class='scala'> <span class='c1'>// instead of concat:</span>
<span class='k'>def</span> <span class='o'>++[</span><span class='kt'>U</span> <span class='k'>&gt;:</span> <span class='kt'>T</span><span class='o'>](</span><span class='n'>that</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>])</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>]</span>

<span class='c1'>// instance method instead of static:</span>
<span class='k'>def</span> <span class='n'>zip</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>](</span><span class='n'>that</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>])</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[(</span><span class='kt'>T</span>, <span class='kt'>U</span><span class='o'>)]</span> 

<span class='c1'>// the implicit evidence argument ensures that dematerialize can only be called on Observables of Notifications:</span>
<span class='k'>def</span> <span class='n'>dematerialize</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>](</span><span class='k'>implicit</span> <span class='n'>evidence</span><span class='k'>:</span> <span class='kt'>T</span> <span class='k'>&lt;:</span><span class='kt'>&lt;</span> <span class='kt'>Notification</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>])</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>]</span> 

<span class='c1'>// additional type parameter U with lower bound to get covariance right:</span>
<span class='k'>def</span> <span class='n'>onErrorResumeNext</span><span class='o'>[</span><span class='kt'>U</span> <span class='k'>&gt;:</span> <span class='kt'>T</span><span class='o'>](</span><span class='n'>resumeFunction</span><span class='k'>:</span> <span class='kt'>Throwable</span> <span class='o'>=&gt;</span> <span class='nc'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>])</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>]</span> 

<span class='c1'>// curried in Scala collections, so curry fold also here:</span>
<span class='k'>def</span> <span class='n'>fold</span><span class='o'>[</span><span class='kt'>R</span><span class='o'>](</span><span class='n'>initialValue</span><span class='k'>:</span> <span class='kt'>R</span><span class='o'>)(</span><span class='n'>accumulator</span><span class='k'>:</span> <span class='o'>(</span><span class='kt'>R</span><span class='o'>,</span> <span class='kt'>T</span><span class='o'>)</span> <span class='k'>=&gt;</span> <span class='n'>R</span><span class='o'>)</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>R</span><span class='o'>]</span> 

<span class='c1'>// using Duration instead of (long timepan, TimeUnit duration):</span>
<span class='k'>def</span> <span class='n'>sample</span><span class='o'>(</span><span class='n'>duration</span><span class='k'>:</span> <span class='kt'>Duration</span><span class='o'>)</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>T</span><span class='o'>]</span> 

<span class='c1'>// called skip in Java, but drop in Scala</span>
<span class='k'>def</span> <span class='n'>drop</span><span class='o'>(</span><span class='n'>n</span><span class='k'>:</span> <span class='kt'>Int</span><span class='o'>)</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>T</span><span class='o'>]</span> 

<span class='c1'>// there&#39;s only mapWithIndex in Java, because Java doesn&#39;t have tuples:</span>
<span class='k'>def</span> <span class='n'>zipWithIndex</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[(</span><span class='kt'>T</span>, <span class='kt'>Int</span><span class='o'>)]</span> 

<span class='c1'>// corresponds to Java&#39;s toList:</span>
<span class='k'>def</span> <span class='n'>toSeq</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>Seq</span><span class='o'>[</span><span class='kt'>T</span><span class='o'>]]</span> 

<span class='c1'>// the implicit evidence argument ensures that switch can only be called on Observables of Observables:</span>
<span class='k'>def</span> <span class='n'>switch</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>](</span><span class='k'>implicit</span> <span class='n'>evidence</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>T</span><span class='o'>]</span> <span class='o'>&lt;:&lt;</span> <span class='nc'>Observable</span><span class='o'>[</span><span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>]])</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>U</span><span class='o'>]</span>

<span class='c1'>// Java&#39;s from becomes apply, and we use Scala Range</span>
<span class='k'>def</span> <span class='n'>apply</span><span class='o'>(</span><span class='n'>range</span><span class='k'>:</span> <span class='kt'>Range</span><span class='o'>)</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>Int</span><span class='o'>]</span>

<span class='c1'>// use Bottom type:</span>
<span class='k'>def</span> <span class='n'>never</span><span class='k'>:</span> <span class='kt'>Observable</span><span class='o'>[</span><span class='kt'>Nothing</span><span class='o'>]</span> 
</code></pre></div>
<p>Also, the Scala Observable is fully covariant in its type parameter, whereas the Java Observable only achieves partial covariance due to limitations of Java&#8217;s type system (or if you can fix this, your suggestions are very welcome).</p>

<p>For more examples, see <a href='https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/examples/RxScalaDemo.scala'>RxScalaDemo.scala</a>.</p>

<p>Scala code using Rx should only import members from <code>rx.lang.scala</code> and below.</p>

<h2 id='documentation'>Documentation</h2>

<p>The API documentation can be found <a href='http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable'>here</a>.</p>

<h2 id='binaries'>Binaries</h2>

<p>Binaries and dependency information for Maven, Ivy, Gradle and others can be found at <a href='http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22rxjava-scala%22'>http://search.maven.org</a>.</p>

<p>Example for Maven:</p>
<div class='highlight'><pre><code class='xml'><span class='nt'>&lt;dependency&gt;</span>
    <span class='nt'>&lt;groupId&gt;</span>com.netflix.rxjava<span class='nt'>&lt;/groupId&gt;</span>
    <span class='nt'>&lt;artifactId&gt;</span>rxjava-scala<span class='nt'>&lt;/artifactId&gt;</span>
    <span class='nt'>&lt;version&gt;</span>x.y.z<span class='nt'>&lt;/version&gt;</span>
<span class='nt'>&lt;/dependency&gt;</span>
</code></pre></div>
<p>and for Ivy:</p>
<div class='highlight'><pre><code class='xml'><span class='nt'>&lt;dependency</span> <span class='na'>org=</span><span class='s'>&quot;com.netflix.rxjava&quot;</span> <span class='na'>name=</span><span class='s'>&quot;rxjava-scala&quot;</span> <span class='na'>rev=</span><span class='s'>&quot;x.y.z&quot;</span> <span class='nt'>/&gt;</span>
</code></pre></div>
<p>and for sbt:</p>
<div class='highlight'><pre><code class='scala'><span class='n'>libraryDependencies</span> <span class='o'>++=</span> <span class='nc'>Seq</span><span class='o'>(</span>
  <span class='s'>&quot;com.netflix.rxjava&quot;</span> <span class='o'>%</span> <span class='s'>&quot;rxjava-scala&quot;</span> <span class='o'>%</span> <span class='s'>&quot;x.y.z&quot;</span>
<span class='o'>)</span>
</code></pre></div>

        <footer>
          Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
