<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>BehaviorSubject - rxjava-scala 0.16.0 API - rx.lang.scala.subjects.BehaviorSubject</title>
          <meta name="description" content="BehaviorSubject - rxjava - scala 0.16.0 API - rx.lang.scala.subjects.BehaviorSubject" />
          <meta name="keywords" content="BehaviorSubject rxjava scala 0.16.0 API rx.lang.scala.subjects.BehaviorSubject" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../../index.html';
            var hash = 'rx.lang.scala.subjects.BehaviorSubject';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <a href="BehaviorSubject$.html" title="Go to companion"><img src="../../../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a href="../../../package.html" class="extype" name="rx">rx</a>.<a href="../../package.html" class="extype" name="rx.lang">lang</a>.<a href="../package.html" class="extype" name="rx.lang.scala">scala</a>.<a href="package.html" class="extype" name="rx.lang.scala.subjects">subjects</a></p>
        <h1><a href="BehaviorSubject$.html" title="Go to companion">BehaviorSubject</a></h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">BehaviorSubject</span><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="rx.lang.scala.subjects.BehaviorSubject"><span>BehaviorSubject</span></li><li class="in" name="rx.lang.scala.Subject"><span>Subject</span></li><li class="in" name="rx.lang.scala.Observer"><span>Observer</span></li><li class="in" name="rx.lang.scala.Observable"><span>Observable</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#++" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="++[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="++[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus$plus" class="name">++</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="that">that: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.++.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.++.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that first emits the items emitted by <code>this</code>, and then the items emitted
by <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that first emits the items emitted by <code>this</code>, and then the items emitted
by <code>that</code>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           an Observable to be appended</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of combining the items emitted by
        this and that, one after the other
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(observer:rx.lang.scala.Observer[T]):rx.lang.scala.Subscription"></a>
      <a id="apply(Observer[T]):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="observer">observer: <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>
        the observer</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="rx.lang.scala.Subject#asJavaObservable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asJavaObservable:rx.Observable[_&lt;:T]"></a>
      <a id="asJavaObservable:rx.Observable[_&lt;:T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">asJavaObservable</span><span class="result">: <span class="extype" name="rx.Observable">rx.Observable</span>[_ &lt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a> → <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Subject#asJavaObserver" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asJavaObserver:rx.Observer[_&gt;:T]"></a>
      <a id="asJavaObserver:rx.Observer[_&gt;:T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">asJavaObserver</span><span class="result">: <span class="extype" name="rx.Observer">rx.Observer</span>[_ &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a> → <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a></dd></dl></div>
    </li><li name="rx.lang.scala.subjects.BehaviorSubject#asJavaSubject" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asJavaSubject:rx.subjects.BehaviorSubject[T]"></a>
      <a id="asJavaSubject:subjects.BehaviorSubject[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">asJavaSubject</span><span class="result">: <span class="extype" name="rx.subjects.BehaviorSubject">subjects.BehaviorSubject</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="rx.lang.scala.subjects.BehaviorSubject">BehaviorSubject</a> → <a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Duration,Scheduler):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable starts a new buffer
periodically, which is determined by the <code>timeshift</code> argument. Each buffer is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new buffer will be created.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new buffers periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Duration):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable starts a new buffer
periodically, which is determined by the <code>timeshift</code> argument. Each buffer is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new buffer will be created.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new buffers periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,count:Int,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Int,Scheduler):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable produces connected
non-overlapping buffers, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers which are emitted after
        a fixed duration or when the buffer has reached maximum capacity (which ever occurs first).
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,count:Int):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Int):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable produces connected
non-overlapping buffers, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers which are emitted after
        a fixed duration or when the buffer has reached maximum capacity (which ever occurs first).
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Scheduler):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers, each of a fixed duration
specified by the <code>timespan</code> argument. When the source Observable completes or encounters
an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers with a fixed duration.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers, each of a fixed duration
specified by the <code>timespan</code> argument. When the source Observable completes or encounters
an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers with a fixed duration.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(count:Int,skip:Int):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Int,Int):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="skip">skip: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces buffers every <code>skip</code> values, each containing <code>count</code>
elements. When the source Observable completes or encounters an error, the current
buffer is emitted, and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt class="param">skip</dt><dd class="cmt"><p>
           How many produced values need to be skipped before starting a new buffer. Note that when <code>skip</code> and
           <code>count</code> are equals that this is the same operation as <code>buffer(int)</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces buffers every <code>skip</code> values containing at most
        <code>count</code> produced values.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(count:Int):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Int):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers, each containing <code>count</code>
elements. When the source Observable completes or encounters an error, the current
buffer is emitted, and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers containing at most
        <code>count</code> produced values.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer[Opening,Closing](openings:rx.lang.scala.Observable[Opening],closings:Opening=&gt;rx.lang.scala.Observable[Closing]):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer[Opening,Closing](Observable[Opening],(Opening)⇒Observable[Closing]):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="tparams">[<span name="Opening">Opening</span>, <span name="Closing">Closing</span>]</span><span class="params">(<span name="openings">openings: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.buffer.Opening">Opening</span>]</span>, <span name="closings">closings: (<span class="extype" name="rx.lang.scala.Observable.buffer.Opening">Opening</span>) ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.buffer.Closing">Closing</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces buffers. Buffers are created when the specified <code>openings</code>
Observable produces an object. Additionally the function argument
is used to create an Observable which produces <span class="extype" name="rx.lang.scala.util.Closing">rx.lang.scala.util.Closing</span> objects. When this
Observable produces such an object, the associated buffer is emitted.
</p></div><dl class="paramcmts block"><dt class="param">openings</dt><dd class="cmt"><p>
           The <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which, when it produces an object, will cause
           another buffer to be created.</p></dd><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every buffer created.
           When this <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated buffer
           is emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces buffers which are created and emitted when the specified <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>s publish certain objects.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer[Closing](closings:()=&gt;rx.lang.scala.Observable[_&lt;:Closing]):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer[Closing](()⇒Observable[_&lt;:Closing]):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="tparams">[<span name="Closing">Closing</span>]</span><span class="params">(<span name="closings">closings: () ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[_ &lt;: <span class="extype" name="rx.lang.scala.Observable.buffer.Closing">Closing</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers. The current buffer is
emitted and replaced with a new buffer when the Observable produced by the specified function produces an object. The function will then
be used to create a new Observable to listen for the end of the next buffer.
</p></div><dl class="paramcmts block"><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every buffer created.
           When this <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated buffer
           is emitted and replaced with a new one.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers, which are emitted
        when the current <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> created with the function argument produces an object.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#cache" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cache:rx.lang.scala.Observable[T]"></a>
      <a id="cache:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cache</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">This method has similar behavior to <a href="../Observable.html#replay:(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[T])" class="extmbr" name="rx.lang.scala.Observable#replay">rx.lang.scala.Observable.replay</a> except that this auto-subscribes to
the source Observable rather than returning a start function and an Observable.</p><div class="fullcomment"><div class="comment cmt"><p>This method has similar behavior to <a href="../Observable.html#replay:(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[T])" class="extmbr" name="rx.lang.scala.Observable#replay">rx.lang.scala.Observable.replay</a> except that this auto-subscribes to
the source Observable rather than returning a start function and an Observable.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/cache.png"></p><p>This is useful when you want an Observable to cache responses and you can't control the
subscribe/unsubscribe behavior of all the <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s.</p><p>When you call <code>cache</code>, it does not yet subscribe to the
source Observable. This only happens when <code>subscribe</code> is called
the first time on the Observable returned by <code>cache()</code>.</p><p>Note: You sacrifice the ability to unsubscribe from the origin when you use the
<code>cache()</code> operator so be careful not to use this operator on Observables that
emit an infinite or very large number of items that will use up memory.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that when first subscribed to, caches all of its notifications for
        the benefit of subsequent subscribers.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="rx.lang.scala.Observable#combineLatest" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="combineLatest[U](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[(T,U)]"></a>
      <a id="combineLatest[U](Observable[U]):Observable[(T,U)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">combineLatest</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="that">that: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.combineLatest.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>, <span class="extype" name="rx.lang.scala.Observable.combineLatest.U">U</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Combines two observables, emitting a pair of the latest values of each of
the source observables each time an event is received from one of the source observables, where the
aggregation is defined by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Combines two observables, emitting a pair of the latest values of each of
the source observables each time an event is received from one of the source observables, where the
aggregation is defined by the given function.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           The second source observable.</p></dd><dt>returns</dt><dd class="cmt"><p>An Observable that combines the source Observables
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#concat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concat[U]:rx.lang.scala.Observable[U]"></a>
      <a id="concat[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">concat</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.concat.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] </p><div class="fullcomment">[use case] <div class="comment cmt"></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">concat</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.concat.U">U</span>]]]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.concat.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#debounce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="debounce(timeout:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="debounce(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">debounce</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/debounce.png"></p><p>Information on debounce vs throttle:</p><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank">http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</a></li><li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank">http://unscriptable.com/2009/03/20/debouncing-javascript-methods/</a></li><li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/" target="_blank">http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/</a></li></ul></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use internally to manage the timers which handle timeout for each event.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>Observable.throttleWithTimeout</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#debounce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="debounce(timeout:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="debounce(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">debounce</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/debounce.png"></p><p>Information on debounce vs throttle:</p><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank">http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</a></li><li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank">http://unscriptable.com/2009/03/20/debouncing-javascript-methods/</a></li><li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/" target="_blank">http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/</a></li></ul></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.
</p></dd><dt>returns</dt><dd class="cmt"><p>An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which filters out values which are too quickly followed up with newer values.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>Observable.throttleWithTimeout</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#dematerialize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dematerialize[U]:rx.lang.scala.Observable[U]"></a>
      <a id="dematerialize[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dematerialize</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.dematerialize.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Returns an Observable that reverses the effect of <a href="../Observable.html#materialize:rx.lang.scala.Observable[rx.lang.scala.Notification[T]]" class="extmbr" name="rx.lang.scala.Observable#materialize">rx.lang.scala.Observable.materialize</a> by
transforming the <a href="../Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects emitted by the source Observable into the items
or notifications they represent.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Returns an Observable that reverses the effect of <a href="../Observable.html#materialize:rx.lang.scala.Observable[rx.lang.scala.Notification[T]]" class="extmbr" name="rx.lang.scala.Observable#materialize">rx.lang.scala.Observable.materialize</a> by
transforming the <a href="../Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects emitted by the source Observable into the items
or notifications they represent.</p><p>This operation is only available if <code>this</code> is of type <code>Observable[Notification[U]]</code> for some <code>U</code>,
otherwise you will get a compilation error.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/dematerialize.png"></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items and notifications embedded in the <a href="../Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects emitted by the source Observable</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dematerialize</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Notification.html" class="extype" name="rx.lang.scala.Notification">Notification</a>[<span class="extype" name="rx.lang.scala.Observable.dematerialize.U">U</span>]]]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.dematerialize.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#distinct" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinct[U](keySelector:T=&gt;U):rx.lang.scala.Observable[T]"></a>
      <a id="distinct[U]((T)⇒U):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinct</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.distinct.U">U</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all items emitted from the source Observable that are distinct according
to a key selector function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all items emitted from the source Observable that are distinct according
to a key selector function.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.key.png">
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>
           a function that projects an emitted item to a key value which is used for deciding whether an item is
           distinct from another one or not</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable of distinct items
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#distinct" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinct:rx.lang.scala.Observable[T]"></a>
      <a id="distinct:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinct</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all distinct items emitted from the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all distinct items emitted from the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable of distinct items
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#distinctUntilChanged" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinctUntilChanged[U](keySelector:T=&gt;U):rx.lang.scala.Observable[T]"></a>
      <a id="distinctUntilChanged[U]((T)⇒U):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinctUntilChanged</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.distinctUntilChanged.U">U</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all items emitted from the source Observable that are sequentially
distinct according to a key selector function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all items emitted from the source Observable that are sequentially
distinct according to a key selector function.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.key.png">
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>
           a function that projects an emitted item to a key value which is used for deciding whether an item is sequentially
           distinct from another one or not</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable of sequentially distinct items
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#distinctUntilChanged" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinctUntilChanged:rx.lang.scala.Observable[T]"></a>
      <a id="distinctUntilChanged:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinctUntilChanged</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all sequentially distinct items emitted from the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all sequentially distinct items emitted from the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable of sequentially distinct items
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnCompleted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnCompleted(onCompleted:()=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnCompleted(()⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnCompleted</span><span class="params">(<span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Invokes an action when the source Observable calls <code>onCompleted</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Invokes an action when the source Observable calls <code>onCompleted</code>.
</p></div><dl class="paramcmts block"><dt class="param">onCompleted</dt><dd class="cmt"><p>the action to invoke when the source Observable calls
                   <code>onCompleted</code></p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable with the side-effecting behavior applied
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,onCompleted:()=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach((T)⇒Unit,(Throwable)⇒Unit,()⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>this function will be called if an error occurs</p></dd><dt class="param">onCompleted</dt><dd class="cmt"><p>the action to invoke when the source Observable calls
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach((T)⇒Unit,(Throwable)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>this function will be called if an error occurs
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(onNext:T=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach((T)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>this function will be called whenever the Observable emits an item
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(observer:rx.lang.scala.Observer[T]):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach(Observer[T]):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="observer">observer: <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>the observer
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnError(onError:Throwable=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnError((Throwable)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnError</span><span class="params">(<span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Invokes an action if the source Observable calls <code>onError</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Invokes an action if the source Observable calls <code>onError</code>.
</p></div><dl class="paramcmts block"><dt class="param">onError</dt><dd class="cmt"><p>the action to invoke if the source Observable calls
               <code>onError</code></p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable with the side-effecting behavior applied
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnNext(onNext:T=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnNext((T)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnNext</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Invokes an action when the source Observable calls <code>onNext</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Invokes an action when the source Observable calls <code>onNext</code>.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>the action to invoke when the source Observable calls <code>onNext</code></p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable with the side-effecting behavior applied
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#drop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="drop(n:Int):rx.lang.scala.Observable[T]"></a>
      <a id="drop(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="n">n: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that skips the first <code>num</code> items emitted by the source
Observable and emits the remainder.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that skips the first <code>num</code> items emitted by the source
Observable and emits the remainder.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skip.png">
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>
           the number of items to skip</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that is identical to the source Observable except that it does not
        emit the first <code>num</code> items that the source emits
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#dropWhile" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropWhile(predicate:T=&gt;Boolean):rx.lang.scala.Observable[T]"></a>
      <a id="dropWhile((T)⇒Boolean):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropWhile</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that bypasses all items from the source Observable as long as the specified
condition holds true.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that bypasses all items from the source Observable as long as the specified
condition holds true. Emits all further source items as soon as the condition becomes false.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipWhile.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           A function to test each item emitted from the source Observable for a condition.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits all items from the source Observable as soon as the condition
        becomes false.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#exists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="exists(p:T=&gt;Boolean):rx.lang.scala.Observable[Boolean]"></a>
      <a id="exists((T)⇒Boolean):Observable[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exists</span><span class="params">(<span name="p">p: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Tests whether a predicate holds for some of the elements of this <code>Observable</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Tests whether a predicate holds for some of the elements of this <code>Observable</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the predicate used to test elements.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable emitting one single Boolean, which is <code>true</code> if the given predicate <code>p</code>
                holds for some of the elements of this Observable, and <code>false</code> otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#filter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="filter(predicate:T=&gt;Boolean):rx.lang.scala.Observable[T]"></a>
      <a id="filter((T)⇒Boolean):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable which only emits those items for which a given predicate holds.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable which only emits those items for which a given predicate holds.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/filter.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           a function that evaluates the items emitted by the source Observable, returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only those items in the original Observable that the filter
        evaluates as <code>true</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="rx.lang.scala.Observable#finallyDo" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finallyDo(action:()=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="finallyDo(()⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finallyDo</span><span class="params">(<span name="action">action: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Registers an function to be called when this Observable invokes <a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> or <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Registers an function to be called when this Observable invokes <a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> or <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/finallyDo.png">
</p></div><dl class="paramcmts block"><dt class="param">action</dt><dd class="cmt"><p>
           an function to be invoked when the source Observable finishes</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the same items as the source Observable, then invokes the function
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#first" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="first:rx.lang.scala.Observable[T]"></a>
      <a id="first:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">first</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the very first item emitted by the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the very first item emitted by the source Observable.
This is just a shorthand for <code>take(1)</code>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/first.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the very first item from the source, or none if the
        source Observable completes without emitting a single item.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#firstOrElse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="firstOrElse[U&gt;:T](default:=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="firstOrElse[U&gt;:T](⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">firstOrElse</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="default">default: ⇒ <span class="extype" name="rx.lang.scala.Observable.firstOrElse.U">U</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.firstOrElse.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">
</p></div><dl class="paramcmts block"><dt class="param">default</dt><dd class="cmt"><p>
           The default value to emit if the source Observable doesn't emit anything.
           This is a by-name parameter, so it is only evaluated if the source Observable doesn't emit anything.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the very first item from the source, or a default value
        if the source Observable completes without emitting any item.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#flatMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMap[R](f:T=&gt;rx.lang.scala.Observable[R]):rx.lang.scala.Observable[R]"></a>
      <a id="flatMap[R]((T)⇒Observable[R]):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatMap.R">R</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatMap.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new Observable by applying a function that you supply to each item emitted by
the source Observable, where that function returns an Observable, and then merging those
resulting Observables and emitting the results of this merger.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new Observable by applying a function that you supply to each item emitted by
the source Observable, where that function returns an Observable, and then merging those
resulting Observables and emitting the results of this merger.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png">
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>
           a function that, when applied to an item emitted by the source Observable, returns
           an Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the result of applying the transformation function to each
        item emitted by the source Observable and merging the results of the Observables
        obtained from this transformation.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#flatten" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatten[U]:rx.lang.scala.Observable[U]"></a>
      <a id="flatten[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatten</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatten.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Flattens the sequence of Observables emitted by <code>this</code> into one Observable, without any
transformation.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Flattens the sequence of Observables emitted by <code>this</code> into one Observable, without any
transformation.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png"></p><p>You can combine the items emitted by multiple Observables so that they act like a single
Observable by using this method.</p><p>This operation is only available if <code>this</code> is of type <code>Observable[Observable[U]]</code> for some <code>U</code>,
otherwise you'll get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of flattening the items emitted
        by the Observables emitted by <code>this</code></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatten</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatten.U">U</span>]]]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatten.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#flattenDelayError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flattenDelayError[U]:rx.lang.scala.Observable[U]"></a>
      <a id="flattenDelayError[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flattenDelayError</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flattenDelayError.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] This behaves like <code>flatten</code> except that if any of the merged Observables
notify of an error via <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, this method will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>This behaves like <code>flatten</code> except that if any of the merged Observables
notify of an error via <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, this method will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png"></p><p>Even if multiple merged Observables send <code>onError</code> notifications, this method will only invoke the <code>onError</code> method of its
Observers once.</p><p>This method allows an Observer to receive all successfully emitted items from all of the
source Observables without being interrupted by an error notification from one of them.</p><p>This operation is only available if <code>this</code> is of type <code>Observable[Observable[U]]</code> for some <code>U</code>,
otherwise you'll get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of flattening the items emitted by
        the Observables emitted by the this Observable</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flattenDelayError</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flattenDelayError.U">U</span>]]]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flattenDelayError.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#foldLeft" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldLeft[R](initialValue:R)(accumulator:(R,T)=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="foldLeft[R](R)((R,T)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldLeft</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="initialValue">initialValue: <span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span></span>)</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span>, <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the final result from the final call to your function as its sole
item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the final result from the final call to your function as its sole
item.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/reduceSeed.png"></p><p>This technique, which is called &quot;reduce&quot; or &quot;aggregate&quot; here, is sometimes called &quot;fold,&quot;
&quot;accumulate,&quot; &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance,
has an <code>inject</code> method that does a similar operation on lists.
</p></div><dl class="paramcmts block"><dt class="param">initialValue</dt><dd class="cmt"><p>
           the initial (seed) accumulator value</p></dd><dt class="param">accumulator</dt><dd class="cmt"><p>
           an accumulator function to be invoked on each item emitted by the source
           Observable, the result of which will be used in the next accumulator call</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item that is the result of accumulating the output
        from the items emitted by the source Observable
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#forall" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="forall(predicate:T=&gt;Boolean):rx.lang.scala.Observable[Boolean]"></a>
      <a id="forall((T)⇒Boolean):Observable[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forall</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits a Boolean that indicates whether all of the items emitted by
the source Observable satisfy a condition.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits a Boolean that indicates whether all of the items emitted by
the source Observable satisfy a condition.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/all.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           a function that evaluates an item and returns a Boolean</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits <code>true</code> if all items emitted by the source
        Observable satisfy the predicate; otherwise, <code>false</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#groupBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="groupBy[K](f:T=&gt;K):rx.lang.scala.Observable[(K,rx.lang.scala.Observable[T])]"></a>
      <a id="groupBy[K]((T)⇒K):Observable[(K,Observable[T])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.groupBy.K">K</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.Observable.groupBy.K">K</span>, <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Groups the items emitted by this Observable according to a specified discriminator function.</p><div class="fullcomment"><div class="comment cmt"><p>Groups the items emitted by this Observable according to a specified discriminator function.
</p></div><dl class="paramcmts block"><dt class="tparam">K</dt><dd class="cmt"><p>
           the type of keys returned by the discriminator function.</p></dd><dt class="param">f</dt><dd class="cmt"><p>
           a function that extracts the key from an item</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits <code>(key, observable)</code> pairs, where <code>observable</code>
        contains all items for which <code>f</code> returned <code>key</code>.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#headOrElse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="headOrElse[U&gt;:T](default:=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="headOrElse[U&gt;:T](⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headOrElse</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="default">default: ⇒ <span class="extype" name="rx.lang.scala.Observable.headOrElse.U">U</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.headOrElse.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">
</p></div><dl class="paramcmts block"><dt class="param">default</dt><dd class="cmt"><p>
           The default value to emit if the source Observable doesn't emit anything.
           This is a by-name parameter, so it is only evaluated if the source Observable doesn't emit anything.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the very first item from the source, or a default value
        if the source Observable completes without emitting any item.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#isEmpty" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isEmpty:rx.lang.scala.Observable[Boolean]"></a>
      <a id="isEmpty:Observable[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isEmpty</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Tests whether this <code>Observable</code> emits no elements.</p><div class="fullcomment"><div class="comment cmt"><p>Tests whether this <code>Observable</code> emits no elements.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting one single Boolean, which is <code>true</code> if this <code>Observable</code>
                emits no elements, and <code>false</code> otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#length" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="length:rx.lang.scala.Observable[Int]"></a>
      <a id="length:Observable[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">length</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that counts the total number of elements in the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that counts the total number of elements in the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the number of counted elements of the source Observable
        as its single item.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#map" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[R](func:T=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="map[R]((T)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="func">func: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.map.R">R</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.map.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable and emits the result.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable and emits the result.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/map.png">
</p></div><dl class="paramcmts block"><dt class="param">func</dt><dd class="cmt"><p>
           a function to apply to each item emitted by the Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items from the source Observable, transformed by the
        given function
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#materialize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="materialize:rx.lang.scala.Observable[rx.lang.scala.Notification[T]]"></a>
      <a id="materialize:Observable[Notification[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">materialize</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Notification.html" class="extype" name="rx.lang.scala.Notification">Notification</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Turns all of the notifications from a source Observable into <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> emissions,
and marks them with their original notification types within <a href="../Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects.</p><div class="fullcomment"><div class="comment cmt"><p>Turns all of the notifications from a source Observable into <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> emissions,
and marks them with their original notification types within <a href="../Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/materialize.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable whose items are the result of materializing the items and
        notifications of the source Observable
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#merge" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="merge[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="merge[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">merge</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="that">that: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.merge.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.merge.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Flattens two Observables into one Observable, without any transformation.</p><div class="fullcomment"><div class="comment cmt"><p>Flattens two Observables into one Observable, without any transformation.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png"></p><p>You can combine items emitted by two Observables so that they act like a single
Observable by using the <code>merge</code> method.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           an Observable to be merged</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits items from <code>this</code> and <code>that</code> until
           <code>this</code> or <code>that</code> emits <code>onError</code> or <code>onComplete</code>.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#mergeDelayError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mergeDelayError[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="mergeDelayError[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mergeDelayError</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="that">that: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.mergeDelayError.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.mergeDelayError.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">This behaves like <a href="../Observable.html#merge[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]" class="extmbr" name="rx.lang.scala.Observable#merge">rx.lang.scala.Observable.merge</a> except that if any of the merged Observables
notify of an error via <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, <code>mergeDelayError</code> will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><div class="fullcomment"><div class="comment cmt"><p>This behaves like <a href="../Observable.html#merge[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]" class="extmbr" name="rx.lang.scala.Observable#merge">rx.lang.scala.Observable.merge</a> except that if any of the merged Observables
notify of an error via <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, <code>mergeDelayError</code> will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png"></p><p>Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only invoke the <code>onError</code> method of its
Observers once.</p><p>This method allows an Observer to receive all successfully emitted items from all of the
source Observables without being interrupted by an error notification from one of them.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           an Observable to be merged</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of flattening the items emitted by
        <code>this</code> and <code>that</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#multicast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="multicast[R&gt;:T](subject:rx.lang.scala.Subject[R]):(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[R])"></a>
      <a id="multicast[R&gt;:T](Subject[R]):(()⇒Subscription,Observable[R])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">multicast</span><span class="tparams">[<span name="R">R &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="subject">subject: <a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a>[<span class="extype" name="rx.lang.scala.Observable.multicast.R">R</span>]</span>)</span><span class="result">: (() ⇒ <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a>, <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.multicast.R">R</span>])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that upon calling the start function causes the source Observable to
push results into the specified subject.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that upon calling the start function causes the source Observable to
push results into the specified subject.
</p></div><dl class="paramcmts block"><dt class="param">subject</dt><dd class="cmt"><p>
           the <code>rx.lang.scala.subjects.Subject</code> to push source items into</p></dd><dt>returns</dt><dd class="cmt"><p>a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> such that when the start function
        is called, the Observable starts to push results into the specified Subject
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#observeOn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="observeOn(scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="observeOn(Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">observeOn</span><span class="params">(<span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronously notify <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s on the specified <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously notify <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s on the specified <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/observeOn.png">
</p></div><dl class="paramcmts block"><dt class="param">scheduler</dt><dd class="cmt"><p>
           the <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to notify <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s on</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified so that its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s are notified on the
        specified <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Subject#onCompleted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onCompleted():Unit"></a>
      <a id="onCompleted():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onCompleted</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Notifies the Observer that the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> has finished sending push-based notifications.</p><div class="fullcomment"><div class="comment cmt"><p>Notifies the Observer that the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> has finished sending push-based notifications.</p><p>The <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> will not call this method if it calls <code>onError</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a> → <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a></dd></dl></div>
    </li><li name="rx.lang.scala.Subject#onError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onError(error:Throwable):Unit"></a>
      <a id="onError(Throwable):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onError</span><span class="params">(<span name="error">error: <span class="extype" name="scala.Throwable">Throwable</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Notifies the Observer that the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> has experienced an error condition.</p><div class="fullcomment"><div class="comment cmt"><p>Notifies the Observer that the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> has experienced an error condition.</p><p>If the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> calls this method, it will not thereafter call <code>onNext</code> or <code>onCompleted</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a> → <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onErrorResumeNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorResumeNext[U&gt;:T](resumeSequence:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="onErrorResumeNext[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorResumeNext</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="resumeSequence">resumeSequence: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to pass control to another Observable rather than invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to pass control to another Observable rather than invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass
another Observable (<code>resumeSequence</code>) to an Observable's
<code>onErrorResumeNext</code> method, if the original Observable encounters an error,
instead of invoking its Observer's <code>onError</code> method, it will instead relinquish
control to <code>resumeSequence</code> which will invoke the Observer's <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a>
method if it is able to do so. In such a case, because no
Observable necessarily invokes <code>onError</code>, the Observer may never know that an
error happened.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeSequence</dt><dd class="cmt"><p>
           a function that returns an Observable that will take over if the source Observable
           encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable, with appropriately modified behavior
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onErrorResumeNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorResumeNext[U&gt;:T](resumeFunction:Throwable=&gt;rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="onErrorResumeNext[U&gt;:T]((Throwable)⇒Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorResumeNext</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="resumeFunction">resumeFunction: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to pass control to another Observable rather than invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to pass control to another Observable rather than invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass a
function that returns an Observable (<code>resumeFunction</code>) to
<code>onErrorResumeNext</code>, if the original Observable encounters an error, instead of
invoking its Observer's <code>onError</code> method, it will instead relinquish control to
the Observable returned from <code>resumeFunction</code>, which will invoke the Observer's
<a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> method if it is able to do so. In such a case, because no
Observable necessarily invokes <code>onError</code>, the Observer may never know that an
error happened.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeFunction</dt><dd class="cmt"><p>
           a function that returns an Observable that will take over if the source Observable
           encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable, with appropriately modified behavior
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onErrorReturn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorReturn[U&gt;:T](resumeFunction:Throwable=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="onErrorReturn[U&gt;:T]((Throwable)⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorReturn</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="resumeFunction">resumeFunction: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.onErrorReturn.U">U</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorReturn.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to emit an item (returned by a specified function) rather than
invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to emit an item (returned by a specified function) rather than
invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/onErrorReturn.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorReturn</code> method changes this behavior. If you pass a function
(<code>resumeFunction</code>) to an Observable's <code>onErrorReturn</code> method, if the
original Observable encounters an error, instead of invoking its Observer's
<code>onError</code> method, it will instead pass the return value of
<code>resumeFunction</code> to the Observer's <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> method.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeFunction</dt><dd class="cmt"><p>
           a function that returns an item that the new Observable will emit if the source
           Observable encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable with appropriately modified behavior
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onExceptionResumeNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onExceptionResumeNext[U&gt;:T](resumeSequence:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="onExceptionResumeNext[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onExceptionResumeNext</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="resumeSequence">resumeSequence: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onExceptionResumeNext.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onExceptionResumeNext.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to pass control to another Observable rather than invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error of type <code>java.lang.Exception</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to pass control to another Observable rather than invoking <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error of type <code>java.lang.Exception</code>.</p><p>This differs from <code>Observable.onErrorResumeNext</code> in that this one does not handle <code>java.lang.Throwable</code> or <code>java.lang.Error</code> but lets those continue through.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass
another Observable (<code>resumeSequence</code>) to an Observable's
<code>onErrorResumeNext</code> method, if the original Observable encounters an error,
instead of invoking its Observer's <code>onError</code> method, it will instead relinquish
control to <code>resumeSequence</code> which will invoke the Observer's <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a>
method if it is able to do so. In such a case, because no
Observable necessarily invokes <code>onError</code>, the Observer may never know that an
error happened.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeSequence</dt><dd class="cmt"><p>
           a function that returns an Observable that will take over if the source Observable
           encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable, with appropriately modified behavior
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Subject#onNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onNext(value:T):Unit"></a>
      <a id="onNext(T):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onNext</span><span class="params">(<span name="value">value: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Provides the Observer with new data.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the Observer with new data.</p><p>The <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> calls this closure 0 or more times.</p><p>The <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> will not call this method again after it calls either <code>onCompleted</code> or <code>onError</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a> → <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#parallel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parallel[R](f:rx.lang.scala.Observable[T]=&gt;rx.lang.scala.Observable[R],scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[R]"></a>
      <a id="parallel[R]((Observable[T])⇒Observable[R],Scheduler):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parallel</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: (<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]) ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Perform work in parallel by sharding an <code>Observable[T]</code> on a <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.</p><div class="fullcomment"><div class="comment cmt"><p>Perform work in parallel by sharding an <code>Observable[T]</code> on a <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>
           a function that applies Observable operators to <code>Observable[T]</code> in parallel and returns an <code>Observable[R]</code></p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           a <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to perform the work on.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the output of the function executed on a <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#parallel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parallel[R](f:rx.lang.scala.Observable[T]=&gt;rx.lang.scala.Observable[R]):rx.lang.scala.Observable[R]"></a>
      <a id="parallel[R]((Observable[T])⇒Observable[R]):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parallel</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: (<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]) ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Perform work in parallel by sharding an <code>Observable[T]</code> on a
<span class="extype" name="rx.lang.scala.concurrency.Schedulers.threadPoolForComputation">computation</span>
<a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.</p><div class="fullcomment"><div class="comment cmt"><p>Perform work in parallel by sharding an <code>Observable[T]</code> on a
<span class="extype" name="rx.lang.scala.concurrency.Schedulers.threadPoolForComputation">computation</span>
<a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>
           a function that applies Observable operators to <code>Observable[T]</code> in parallel and returns an <code>Observable[R]</code></p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the output of the function executed on a <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#product" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="product:rx.lang.scala.Observable[T]"></a>
      <a id="product:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">product</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Returns an Observable that multiplies up the elements of this Observable.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Returns an Observable that multiplies up the elements of this Observable.</p><p>This operation is only available if the elements of this Observable are numbers, otherwise
you will get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the product of all the elements of the source Observable
        as its single item.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">product</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: <span class="extype" name="scala.Numeric">Numeric</span>[<span class="extype" name="rx.lang.scala.Observable.product.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.product.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#publish" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="publish:rx.lang.scala.observables.ConnectableObservable[T]"></a>
      <a id="publish:ConnectableObservable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">publish</span><span class="result">: <a href="../observables/ConnectableObservable.html" class="extype" name="rx.lang.scala.observables.ConnectableObservable">ConnectableObservable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>, which waits until the start function is called before it begins emitting
items to those <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s that have subscribed to it.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>, which waits until the start function is called before it begins emitting
items to those <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s that have subscribed to it.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/publishConnect.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an <a href="../observables/ConnectableObservable.html" class="extype" name="rx.lang.scala.observables.ConnectableObservable">rx.lang.scala.observables.ConnectableObservable</a>.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#reduce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduce[U&gt;:T](accumulator:(U,U)=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="reduce[U&gt;:T]((U,U)⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span>, <span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by the source Observable into the same function, and so on until all items have been emitted
by the source Observable, and emits the final result from the final call to your function as
its sole item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by the source Observable into the same function, and so on until all items have been emitted
by the source Observable, and emits the final result from the final call to your function as
its sole item.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/reduce.png"></p><p>This technique, which is called &quot;reduce&quot; or &quot;aggregate&quot; here, is sometimes called &quot;fold,&quot;
&quot;accumulate,&quot; &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance,
has an <code>inject</code> method that does a similar operation on lists.
</p></div><dl class="paramcmts block"><dt class="param">accumulator</dt><dd class="cmt"><p>
           An accumulator function to be invoked on each item emitted by the source
           Observable, whose result will be used in the next accumulator call</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item that is the result of accumulating the
        output from the source Observable
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#replay" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="replay:(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[T])"></a>
      <a id="replay:(()⇒Subscription,Observable[T])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replay</span><span class="result">: (() ⇒ <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a>, <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that shares a single subscription to the underlying
Observable that will replay all of its items and notifications to any future <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that shares a single subscription to the underlying
Observable that will replay all of its items and notifications to any future <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a pair of a start function and an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> such that when the start function
        is called, the Observable starts to emit items to its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#retry" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="retry:rx.lang.scala.Observable[T]"></a>
      <a id="retry:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">retry</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retry subscription to origin Observable whenever onError is called (infinite retry count).</p><div class="fullcomment"><div class="comment cmt"><p>Retry subscription to origin Observable whenever onError is called (infinite retry count).</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png"></p><p>If <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">rx.lang.scala.Observer.onError</a> is invoked the source Observable will be re-subscribed to.</p><p>Any <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">rx.lang.scala.Observer.onNext</a> calls received on each attempt will be emitted and concatenated together.</p><p>For example, if an Observable fails on first time but emits [1, 2] then succeeds the second time and
emits [1, 2, 3, 4, 5] then the complete output would be [1, 2, 1, 2, 3, 4, 5, onCompleted].</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Observable with retry logic.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#retry" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="retry(retryCount:Int):rx.lang.scala.Observable[T]"></a>
      <a id="retry(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">retry</span><span class="params">(<span name="retryCount">retryCount: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retry subscription to origin Observable upto given retry count.</p><div class="fullcomment"><div class="comment cmt"><p>Retry subscription to origin Observable upto given retry count.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png"></p><p>If <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">rx.lang.scala.Observer.onError</a> is invoked the source Observable will be re-subscribed to as many times as defined by retryCount.</p><p>Any <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">rx.lang.scala.Observer.onNext</a> calls received on each attempt will be emitted and concatenated together.</p><p>For example, if an Observable fails on first time but emits [1, 2] then succeeds the second time and
emits [1, 2, 3, 4, 5] then the complete output would be [1, 2, 1, 2, 3, 4, 5, onCompleted].
</p></div><dl class="paramcmts block"><dt class="param">retryCount</dt><dd class="cmt"><p>
           Number of retry attempts before failing.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable with retry logic.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#sample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sample(duration:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="sample(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sample</span><span class="params">(<span name="duration">duration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/sample.png">
</p></div><dl class="paramcmts block"><dt class="param">duration</dt><dd class="cmt"><p>the sampling rate</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           the <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when sampling</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the results of sampling the items emitted by the source
        Observable at the specified time interval
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#sample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sample(duration:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="sample(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sample</span><span class="params">(<span name="duration">duration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/sample.png">
</p></div><dl class="paramcmts block"><dt class="param">duration</dt><dd class="cmt"><p>the sampling rate</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the results of sampling the items emitted by the source
        Observable at the specified time interval
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#scan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scan[U&gt;:T](accumulator:(U,U)=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="scan[U&gt;:T]((U,U)⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.scan.U">U</span>, <span class="extype" name="rx.lang.scala.Observable.scan.U">U</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.scan.U">U</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.scan.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the
first item emitted by a source Observable, then feeds the result of that
function along with the second item emitted by an Observable into the
same function, and so on until all items have been emitted by the source
Observable, emitting the result of each of these iterations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the
first item emitted by a source Observable, then feeds the result of that
function along with the second item emitted by an Observable into the
same function, and so on until all items have been emitted by the source
Observable, emitting the result of each of these iterations.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scan.png"></p></div><dl class="paramcmts block"><dt class="param">accumulator</dt><dd class="cmt"><p>
           an accumulator function to be invoked on each item emitted by the source
           Observable, whose result will be emitted to <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s via
           <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> and used in the next accumulator call.</p></dd><dt>returns</dt><dd class="cmt"><p>
        an Observable that emits the results of each call to the
        accumulator function
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#scan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scan[R](initialValue:R)(accumulator:(R,T)=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="scan[R](R)((R,T)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="initialValue">initialValue: <span class="extype" name="rx.lang.scala.Observable.scan.R">R</span></span>)</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.scan.R">R</span>, <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.scan.R">R</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.scan.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the result of each of these iterations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the result of each of these iterations.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scanSeed.png"></p><p>This sort of function is sometimes called an accumulator.</p><p>Note that when you pass a seed to <code>scan()</code> the resulting Observable will emit
that seed as its first emitted item.
</p></div><dl class="paramcmts block"><dt class="param">initialValue</dt><dd class="cmt"><p>
           the initial (seed) accumulator value</p></dd><dt class="param">accumulator</dt><dd class="cmt"><p>
           an accumulator function to be invoked on each item emitted by the source
           Observable, whose result will be emitted to <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s via
           <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> and used in the next accumulator call.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the results of each call to the accumulator function
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#size" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="size:rx.lang.scala.Observable[Int]"></a>
      <a id="size:Observable[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">size</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that counts the total number of elements in the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that counts the total number of elements in the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the number of counted elements of the source Observable
        as its single item.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the scheduler to use
</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit,Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the scheduler to use
</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,onCompleted:()=&gt;Unit,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit,()⇒Unit,Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt class="param">onCompleted</dt><dd class="cmt"><p>
        this function will be called when this Observable has finished emitting items</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the scheduler to use
</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,onCompleted:()=&gt;Unit):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit,()⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt class="param">onCompleted</dt><dd class="cmt"><p>
        this function will be called when this Observable has finished emitting items</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(observer:rx.lang.scala.Observer[T]):rx.lang.scala.Subscription"></a>
      <a id="subscribe(Observer[T]):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="observer">observer: <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>
        the observer</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(observer:rx.lang.scala.Observer[T],scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe(Observer[T],Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="observer">observer: <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>
        the observer</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> on which Observers subscribe to the Observable</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe():rx.lang.scala.Subscription"></a>
      <a id="subscribe():Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">()</span><span class="result">: <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>
        a <a href="../Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribeOn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribeOn(scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="subscribeOn(Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribeOn</span><span class="params">(<span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronously subscribes and unsubscribes Observers on the specified <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously subscribes and unsubscribes Observers on the specified <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/subscribeOn.png">
</p></div><dl class="paramcmts block"><dt class="param">scheduler</dt><dd class="cmt"><p>
           the <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to perform subscription and unsubscription actions on</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified so that its subscriptions and unsubscriptions happen
        on the specified <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#sum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sum:rx.lang.scala.Observable[T]"></a>
      <a id="sum:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sum</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Returns an Observable that sums up the elements of this Observable.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Returns an Observable that sums up the elements of this Observable.</p><p>This operation is only available if the elements of this Observable are numbers, otherwise
you will get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the sum of all the elements of the source Observable
        as its single item.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sum</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: <span class="extype" name="scala.Numeric">Numeric</span>[<span class="extype" name="rx.lang.scala.Observable.sum.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.sum.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#switch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="switch[U]:rx.lang.scala.Observable[U]"></a>
      <a id="switch[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">switch</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.switch.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Given an Observable that emits Observables, creates a single Observable that
emits the items emitted by the most recently published of those Observables.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Given an Observable that emits Observables, creates a single Observable that
emits the items emitted by the most recently published of those Observables.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png"></p><p>This operation is only available if <code>this</code> is of type <code>Observable[Observable[U]]</code> for some <code>U</code>,
otherwise you'll get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the items emitted by the most recently published
        Observable</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">switch</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>], <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.switch.U">U</span>]]]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.switch.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#synchronize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronize:rx.lang.scala.Observable[T]"></a>
      <a id="synchronize:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronize</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps this Observable in another Observable that ensures that the resulting
Observable is chronologically well-behaved.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps this Observable in another Observable that ensures that the resulting
Observable is chronologically well-behaved.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png"></p><p>A well-behaved Observable does not interleave its invocations of the <a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a>, <a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a>, and <a href="../Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> methods of
its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s; it invokes <code>onCompleted</code> or <code>onError</code> only once; and it never invokes <code>onNext</code> after invoking either <code>onCompleted</code> or <code>onError</code>.
<code>synchronize</code> enforces this, and the Observable it returns invokes <code>onNext</code> and <code>onCompleted</code> or <code>onError</code> synchronously.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that is a chronologically well-behaved version of the source
        Observable, and that synchronously notifies its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#take" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="take(n:Int):rx.lang.scala.Observable[T]"></a>
      <a id="take(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">take</span><span class="params">(<span name="n">n: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the first <code>num</code> items emitted by the source
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the first <code>num</code> items emitted by the source
Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/take.png"></p><p>This method returns an Observable that will invoke a subscribing <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>'s
<a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> function a maximum of <code>num</code> times before invoking
<a href="../Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a>.
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>
           the number of items to take</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the first <code>num</code> items from the source
        Observable, or all of the items from the source Observable if that Observable emits
        fewer than <code>num</code> items
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#takeRight" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeRight(count:Int):rx.lang.scala.Observable[T]"></a>
      <a id="takeRight(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeRight</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the last <code>count</code> items emitted by the source
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the last <code>count</code> items emitted by the source
Observable.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/last.png">
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           the number of items to emit from the end of the sequence emitted by the source
           Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the last <code>count</code> items emitted by the source
        Observable
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#takeUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeUntil[E](that:rx.lang.scala.Observable[E]):rx.lang.scala.Observable[T]"></a>
      <a id="takeUntil[E](Observable[E]):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeUntil</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="that">that: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.takeUntil.E">E</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the items from the source Observable only until the
<code>other</code> Observable emits an item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the items from the source Observable only until the
<code>other</code> Observable emits an item.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeUntil.png">
</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>
           the type of items emitted by <code>other</code></p></dd><dt class="param">that</dt><dd class="cmt"><p>
           the Observable whose first emitted item will cause <code>takeUntil</code> to stop
           emitting items from the source Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items of the source Observable until such time as
        <code>other</code> emits its first item
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#takeWhile" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeWhile(predicate:T=&gt;Boolean):rx.lang.scala.Observable[T]"></a>
      <a id="takeWhile((T)⇒Boolean):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeWhile</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits items emitted by the source Observable so long as a
specified condition is true.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits items emitted by the source Observable so long as a
specified condition is true.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeWhile.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           a function that evaluates an item emitted by the source Observable and returns a
           Boolean</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items from the source Observable so long as each item
        satisfies the condition defined by <code>predicate</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleFirst" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleFirst(skipDuration:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="throttleFirst(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleFirst</span><span class="params">(<span name="skipDuration">skipDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><p>This differs from <code>Observable.throttleLast</code> in that this only tracks passage of time whereas <code>Observable.throttleLast</code> ticks at scheduled intervals.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleFirst.png">
</p></div><dl class="paramcmts block"><dt class="param">skipDuration</dt><dd class="cmt"><p>
           Time to wait before sending another value after emitting last value.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleFirst" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleFirst(skipDuration:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="throttleFirst(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleFirst</span><span class="params">(<span name="skipDuration">skipDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><p>This differs from <code>Observable.throttleLast</code> in that this only tracks passage of time whereas <code>Observable.throttleLast</code> ticks at scheduled intervals.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleFirst.png">
</p></div><dl class="paramcmts block"><dt class="param">skipDuration</dt><dd class="cmt"><p>
           Time to wait before sending another value after emitting last value.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use internally to manage the timers which handle timeout for each event.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleLast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleLast(intervalDuration:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="throttleLast(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleLast</span><span class="params">(<span name="intervalDuration">intervalDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><p>This differs from <code>Observable.throttleFirst</code> in that this ticks along at a scheduled interval whereas <code>Observable.throttleFirst</code> does not tick, it just tracks passage of time.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleLast.png">
</p></div><dl class="paramcmts block"><dt class="param">intervalDuration</dt><dd class="cmt"><p>
           Duration of windows within with the last value will be chosen.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleLast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleLast(intervalDuration:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="throttleLast(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleLast</span><span class="params">(<span name="intervalDuration">intervalDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><p>This differs from <code>Observable.throttleFirst</code> in that this ticks along at a scheduled interval whereas <code>Observable.throttleFirst</code> does not tick, it just tracks passage of time.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleLast.png">
</p></div><dl class="paramcmts block"><dt class="param">intervalDuration</dt><dd class="cmt"><p>
           Duration of windows within with the last value will be chosen.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleWithTimeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleWithTimeout(timeout:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="throttleWithTimeout(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleWithTimeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleWithTimeout.png">
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use internally to manage the timers which handle timeout for each event.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>Observable.debounce</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleWithTimeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleWithTimeout(timeout:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="throttleWithTimeout(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleWithTimeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleWithTimeout.png"></p><p>Information on debounce vs throttle:</p><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank">http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</a></li><li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank">http://unscriptable.com/2009/03/20/debouncing-javascript-methods/</a></li><li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/" target="_blank">http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/</a></li></ul></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.
</p></dd><dt>returns</dt><dd class="cmt"><p>An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which filters out values which are too quickly followed up with newer values.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>Observable.debounce</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timestamp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timestamp:rx.lang.scala.Observable[(Long,T)]"></a>
      <a id="timestamp:Observable[(Long,T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timestamp</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps each item emitted by a source Observable in a timestamped tuple.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps each item emitted by a source Observable in a timestamped tuple.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/timestamp.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits timestamped items from the source Observable
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#toBlockingObservable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toBlockingObservable:rx.lang.scala.observables.BlockingObservable[T]"></a>
      <a id="toBlockingObservable:BlockingObservable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toBlockingObservable</span><span class="result">: <a href="../observables/BlockingObservable.html" class="extype" name="rx.lang.scala.observables.BlockingObservable">BlockingObservable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Converts an Observable into a <a href="../observables/BlockingObservable.html" class="extype" name="rx.lang.scala.observables.BlockingObservable">rx.lang.scala.observables.BlockingObservable</a> (an Observable with blocking
operators).</p><div class="fullcomment"><div class="comment cmt"><p>Converts an Observable into a <a href="../observables/BlockingObservable.html" class="extype" name="rx.lang.scala.observables.BlockingObservable">rx.lang.scala.observables.BlockingObservable</a> (an Observable with blocking
operators).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators">Blocking Observable Operators</a>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#toSeq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toSeq:rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="toSeq:Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSeq</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits a single item, a list composed of all the items emitted by
the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits a single item, a list composed of all the items emitted by
the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toList.png"></p><p>Normally, an Observable that returns multiple items will do so by invoking its <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>'s
<a href="../Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> method for each such item. You can change
this behavior, instructing the Observable to compose a list of all of these items and then to
invoke the Observer's <code>onNext</code> function once, passing it the entire list, by
calling the Observable's <code>toList</code> method prior to calling its <code>Observable.subscribe</code> method.</p><p>Be careful not to use this operator on Observables that emit infinite or very large numbers
of items, as you do not have the option to unsubscribe.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item: a List containing all of the items emitted by
        the source Observable.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Duration,Scheduler):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable starts a new window
periodically, which is determined by the <code>timeshift</code> argument. Each window is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new window will be created.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new windows periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Duration):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable starts a new window
periodically, which is determined by the <code>timeshift</code> argument. Each window is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new window will be created.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new windows periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,count:Int,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Int,Scheduler):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows which are emitted after
        a fixed duration or when the window has reached maximum capacity (which ever occurs first).
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,count:Int):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Int):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows which are emitted after
        a fixed duration or when the window has reached maximum capacity (which ever occurs first).
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Scheduler):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument. When the source
Observable completes or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="../Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows with a fixed duration.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument. When the source
Observable completes or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows with a fixed duration.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(count:Int,skip:Int):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Int,Int):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="skip">skip: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces windows every
<code>skip</code> values, each containing <code>count</code> elements. When the source Observable completes or encounters an error,
the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt class="param">skip</dt><dd class="cmt"><p>
           How many produced values need to be skipped before starting a new window. Note that when <code>skip</code> and
           <code>count</code> are equal that this is the same operation as <code>window(int)</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces windows every <code>skip</code> values containing at most
        <code>count</code> produced values.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(count:Int):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Int):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each containing <code>count</code> elements. When the source Observable completes or
encounters an error, the current window is emitted, and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows containing at most
        <code>count</code> produced values.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window[Opening,Closing](openings:rx.lang.scala.Observable[Opening],closings:Opening=&gt;rx.lang.scala.Observable[Closing]):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window[Opening,Closing](Observable[Opening],(Opening)⇒Observable[Closing]):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="tparams">[<span name="Opening">Opening</span>, <span name="Closing">Closing</span>]</span><span class="params">(<span name="openings">openings: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.window.Opening">Opening</span>]</span>, <span name="closings">closings: (<span class="extype" name="rx.lang.scala.Observable.window.Opening">Opening</span>) ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.window.Closing">Closing</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces windows.
Chunks are created when the specified <code>openings</code> Observable produces an object.
Additionally the <code>closings</code> argument is used to create an Observable which produces <span class="extype" name="rx.lang.scala.util.Closing">rx.lang.scala.util.Closing</span> objects.
When this Observable produces such an object, the associated window is emitted.
</p></div><dl class="paramcmts block"><dt class="param">openings</dt><dd class="cmt"><p>
           The <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which when it produces an object, will cause
           another window to be created.</p></dd><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every window created.
           When this <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated window
           is emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces windows which are created and emitted when the specified <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>s publish certain objects.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window[Closing](closings:()=&gt;rx.lang.scala.Observable[Closing]):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window[Closing](()⇒Observable[Closing]):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="tparams">[<span name="Closing">Closing</span>]</span><span class="params">(<span name="closings">closings: () ⇒ <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.window.Closing">Closing</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows. The current window is emitted and replaced with a new window when the
Observable produced by the specified function produces an object.
The function will then be used to create a new Observable to listen for the end of the next
window.
</p></div><dl class="paramcmts block"><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every window created.
           When this <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated window
           is emitted and replaced with a new one.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows, which are emitted
        when the current <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> created with the function argument produces an object.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#withFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withFilter(p:T=&gt;Boolean):rx.lang.scala.WithFilter[T]"></a>
      <a id="withFilter((T)⇒Boolean):WithFilter[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFilter</span><span class="params">(<span name="p">p: (<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="rx.lang.scala.WithFilter">WithFilter</span>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#zip" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zip[U](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[(T,U)]"></a>
      <a id="zip[U](Observable[U]):Observable[(T,U)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="that">that: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.zip.U">U</span>]</span>)</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>, <span class="extype" name="rx.lang.scala.Observable.zip.U">U</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable formed from this Observable and another Observable by combining
corresponding elements in pairs.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable formed from this Observable and another Observable by combining
corresponding elements in pairs.
The number of <code>onNext</code> invocations of the resulting <code>Observable[(T, U)]</code>
is the minumum of the number of <code>onNext</code> invocations of <code>this</code> and <code>that</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#zipWithIndex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zipWithIndex:rx.lang.scala.Observable[(T,Int)]"></a>
      <a id="zipWithIndex:Observable[(T,Int)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipWithIndex</span><span class="result">: <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>, <span class="extype" name="scala.Int">Int</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Zips this Observable with its indices.</p><div class="fullcomment"><div class="comment cmt"><p>Zips this Observable with its indices.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An Observable emitting pairs consisting of all elements of this Observable paired with
        their index. Indices start at 0.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="rx.lang.scala.Subject">
              <h3>Inherited from <a href="../Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</h3>
            </div><div class="parent" name="rx.lang.scala.Observer">
              <h3>Inherited from <a href="../Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</h3>
            </div><div class="parent" name="rx.lang.scala.Observable">
              <h3>Inherited from <a href="../Observable.html" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.subjects.BehaviorSubject.T">T</span>]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../../lib/template.js"></script>
    </body>
      </html>