<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>Observable - rxjava-scala 0.18.1 API - rx.lang.scala.Observable</title>
          <meta name="description" content="Observable - rxjava - scala 0.18.1 API - rx.lang.scala.Observable" />
          <meta name="keywords" content="Observable rxjava scala 0.18.1 API rx.lang.scala.Observable" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'rx.lang.scala.Observable';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <a href="Observable$.html" title="Go to companion"><img src="../../../lib/trait_to_object_big.png" /></a>
        <p id="owner"><a href="../../package.html" class="extype" name="rx">rx</a>.<a href="../package.html" class="extype" name="rx.lang">lang</a>.<a href="package.html" class="extype" name="rx.lang.scala">scala</a></p>
        <h1><a href="Observable$.html" title="Go to companion">Observable</a></h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">Observable</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>The Observable interface that implements the Reactive Pattern.</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a href="subjects/AsyncSubject.html" class="extype" name="rx.lang.scala.subjects.AsyncSubject">AsyncSubject</a>, <a href="subjects/BehaviorSubject.html" class="extype" name="rx.lang.scala.subjects.BehaviorSubject">BehaviorSubject</a>, <a href="observables/ConnectableObservable.html" class="extype" name="rx.lang.scala.observables.ConnectableObservable">ConnectableObservable</a>, <a href="subjects/ReplaySubject.html" class="extype" name="rx.lang.scala.subjects.ReplaySubject">ReplaySubject</a>, <a href="Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="rx.lang.scala.Observable"><span>Observable</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#++" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="++[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="++[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus$plus" class="name">++</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.++.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.++.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that first emits the items emitted by <code>this</code>, and then the items emitted
by <code>that</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that first emits the items emitted by <code>this</code>, and then the items emitted
by <code>that</code>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/concat.png">
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           an Observable to be appended</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of combining the items emitted by
        this and that, one after the other
</p></dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#amb" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="amb[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="amb[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">amb</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.amb.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.amb.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Given two Observables, mirror the one that first emits an item.</p><div class="fullcomment"><div class="comment cmt"><p>Given two Observables, mirror the one that first emits an item.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/amb.png">
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           an Observable competing to react first</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the same sequence of items as whichever of <code>this</code> or <code>that</code> first emitted an item.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(index:Int):rx.lang.scala.Observable[T]"></a>
      <a id="apply(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="index">index: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
source Observbable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
source Observbable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/elementAt.png">
</p></div><dl class="paramcmts block"><dt class="param">index</dt><dd class="cmt"><p>
           the zero-based index of the item to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item: the item at the specified position in the sequence of
        those emitted by the source Observable</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">IndexOutOfBoundsException<p>
            if index is less than 0</p></span></dd><dt>See also</dt><dd><span class="cmt"><p><code>Observable.elementAt</code></p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(observer:rx.lang.scala.Observer[T]):rx.lang.scala.Subscription"></a>
      <a id="apply(Observer[T]):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="observer">observer: <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>
        the observer</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Duration,Scheduler):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable starts a new buffer
periodically, which is determined by the <code>timeshift</code> argument. Each buffer is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new buffer will be created.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new buffers periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Duration):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable starts a new buffer
periodically, which is determined by the <code>timeshift</code> argument. Each buffer is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new buffer will be created.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new buffers periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,count:Int,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Int,Scheduler):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable produces connected
non-overlapping buffers, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers which are emitted after
        a fixed duration or when the buffer has reached maximum capacity (which ever occurs first).
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,count:Int):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Int):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values. This Observable produces connected
non-overlapping buffers, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers which are emitted after
        a fixed duration or when the buffer has reached maximum capacity (which ever occurs first).
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration,Scheduler):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers, each of a fixed duration
specified by the <code>timespan</code> argument. When the source Observable completes or encounters
an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers with a fixed duration.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(timespan:scala.concurrent.duration.Duration):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Duration):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers, each of a fixed duration
specified by the <code>timespan</code> argument. When the source Observable completes or encounters
an error, the current buffer is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each buffer is collecting values before it should be emitted, and
           replaced with a new buffer.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers with a fixed duration.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(count:Int,skip:Int):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Int,Int):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="skip">skip: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces buffers every <code>skip</code> values, each containing <code>count</code>
elements. When the source Observable completes or encounters an error, the current
buffer is emitted, and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt class="param">skip</dt><dd class="cmt"><p>
           How many produced values need to be skipped before starting a new buffer. Note that when <code>skip</code> and
           <code>count</code> are equals that this is the same operation as <code>buffer(int)</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces buffers every <code>skip</code> values containing at most
        <code>count</code> produced values.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(count:Int):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(Int):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers, each containing <code>count</code>
elements. When the source Observable completes or encounters an error, the current
buffer is emitted, and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each buffer before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers containing at most
        <code>count</code> produced values.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer[Opening](openings:rx.lang.scala.Observable[Opening],closings:Opening=&gt;rx.lang.scala.Observable[Any]):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer[Opening](Observable[Opening],(Opening)⇒Observable[Any]):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="tparams">[<span name="Opening">Opening</span>]</span><span class="params">(<span name="openings">openings: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.buffer.Opening">Opening</span>]</span>, <span name="closings">closings: (<span class="extype" name="rx.lang.scala.Observable.buffer.Opening">Opening</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces buffers. Buffers are created when the specified <code>openings</code>
Observable produces an object. That object is used to construct an Observable to emit buffers, feeding it into <code>closings</code> function.
Buffers are emitted when the created Observable produces an object.
</p></div><dl class="paramcmts block"><dt class="param">openings</dt><dd class="cmt"><p>
           The <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which, when it produces an object, will cause
           another buffer to be created.</p></dd><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every buffer created.
           When this <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated buffer
           is emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces buffers which are created and emitted when the specified <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>s publish certain objects.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#buffer" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="buffer(closings:()=&gt;rx.lang.scala.Observable[Any]):rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="buffer(()⇒Observable[Any]):Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">buffer</span><span class="params">(<span name="closings">closings: () ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces buffers of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces buffers of collected values.</p><p>This Observable produces connected non-overlapping buffers. The current buffer is
emitted and replaced with a new buffer when the Observable produced by the specified function produces an object. The function will then
be used to create a new Observable to listen for the end of the next buffer.
</p></div><dl class="paramcmts block"><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every buffer created.
           When this <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated buffer
           is emitted and replaced with a new one.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping buffers, which are emitted
        when the current <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> created with the function argument produces an object.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#cache" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cache:rx.lang.scala.Observable[T]"></a>
      <a id="cache:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cache</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">This method has similar behavior to <a href="#replay:(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[T])" class="extmbr" name="rx.lang.scala.Observable#replay">rx.lang.scala.Observable.replay</a> except that this auto-subscribes to
the source Observable rather than returning a start function and an Observable.</p><div class="fullcomment"><div class="comment cmt"><p>This method has similar behavior to <a href="#replay:(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[T])" class="extmbr" name="rx.lang.scala.Observable#replay">rx.lang.scala.Observable.replay</a> except that this auto-subscribes to
the source Observable rather than returning a start function and an Observable.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/cache.png"></p><p>This is useful when you want an Observable to cache responses and you can't control the
subscribe/unsubscribe behavior of all the <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s.</p><p>When you call <code>cache</code>, it does not yet subscribe to the
source Observable. This only happens when <code>subscribe</code> is called
the first time on the Observable returned by <code>cache()</code>.</p><p>Note: You sacrifice the ability to unsubscribe from the origin when you use the
<code>cache()</code> operator so be careful not to use this operator on Observables that
emit an infinite or very large number of items that will use up memory.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that when first subscribed to, caches all of its notifications for
        the benefit of subsequent subscribers.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="rx.lang.scala.Observable#combineLatest" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="combineLatest[U,R](that:rx.lang.scala.Observable[U],f:(T,U)=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="combineLatest[U,R](Observable[U],(T,U)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">combineLatest</span><span class="tparams">[<span name="U">U</span>, <span name="R">R</span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.combineLatest.U">U</span>]</span>, <span name="f">f: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>, <span class="extype" name="rx.lang.scala.Observable.combineLatest.U">U</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.combineLatest.R">R</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.combineLatest.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Combines two observables, emitting some type <code>R</code> specified in the function f,
each time an event is received from one of the source observables, where the aggregation
is defined by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Combines two observables, emitting some type <code>R</code> specified in the function f,
each time an event is received from one of the source observables, where the aggregation
is defined by the given function.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
          The second source observable.</p></dd><dt class="param">f</dt><dd class="cmt"><p>
               The function that is used combine the emissions of the two observables.</p></dd><dt>returns</dt><dd class="cmt"><p>An Observable that combines the source Observables according to the function f.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#combineLatest" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="combineLatest[U](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[(T,U)]"></a>
      <a id="combineLatest[U](Observable[U]):Observable[(T,U)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">combineLatest</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.combineLatest.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.Observable.T">T</span>, <span class="extype" name="rx.lang.scala.Observable.combineLatest.U">U</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Combines two observables, emitting a pair of the latest values of each of
the source observables each time an event is received from one of the source observables, where the
aggregation is defined by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Combines two observables, emitting a pair of the latest values of each of
the source observables each time an event is received from one of the source observables, where the
aggregation is defined by the given function.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           The second source observable.</p></dd><dt>returns</dt><dd class="cmt"><p>An Observable that combines the source Observables
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#concat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concat[U]:rx.lang.scala.Observable[U]"></a>
      <a id="concat[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">concat</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.concat.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] </p><div class="fullcomment">[use case] <div class="comment cmt"></div><dl class="attributes block"> <div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">concat</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>], <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.concat.U">U</span>]]]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.concat.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#debounce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="debounce(timeout:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="debounce(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">debounce</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/debounce.png"></p><p>Information on debounce vs throttle:</p><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank">http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</a></li><li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank">http://unscriptable.com/2009/03/20/debouncing-javascript-methods/</a></li><li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/" target="_blank">http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/</a></li></ul></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use internally to manage the timers which handle timeout for each event.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>Observable.throttleWithTimeout</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#debounce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="debounce(timeout:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="debounce(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">debounce</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/debounce.png"></p><p>Information on debounce vs throttle:</p><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank">http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</a></li><li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank">http://unscriptable.com/2009/03/20/debouncing-javascript-methods/</a></li><li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/" target="_blank">http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/</a></li></ul></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.
</p></dd><dt>returns</dt><dd class="cmt"><p>An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which filters out values which are too quickly followed up with newer values.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>Observable.throttleWithTimeout</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#delay" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delay(delay:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="delay(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delay</span><span class="params">(<span name="delay">delay: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
specified delay.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
specified delay. Error notifications from the source Observable are not delayed.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delay.s.png">
</p></div><dl class="paramcmts block"><dt class="param">delay</dt><dd class="cmt"><p>the delay to shift the source by</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>the Scheduler to use for delaying</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable shifted in time by the specified delay
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#delay" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delay(delay:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="delay(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delay</span><span class="params">(<span name="delay">delay: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
specified delay.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the items emitted by the source Observable shifted forward in time by a
specified delay. Error notifications from the source Observable are not delayed.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delay.png">
</p></div><dl class="paramcmts block"><dt class="param">delay</dt><dd class="cmt"><p>the delay to shift the source by</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable shifted in time by the specified delay
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#delaySubscription" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delaySubscription(delay:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="delaySubscription(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delaySubscription</span><span class="params">(<span name="delay">delay: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return an Observable that delays the subscription to the source Observable by a given amount of time,
both waiting and subscribing on a given Scheduler.</p><div class="fullcomment"><div class="comment cmt"><p>Return an Observable that delays the subscription to the source Observable by a given amount of time,
both waiting and subscribing on a given Scheduler.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delaySubscription.s.png">
</p></div><dl class="paramcmts block"><dt class="param">delay</dt><dd class="cmt"><p>the time to delay the subscription</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>the Scheduler on which the waiting and subscription will happen</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that delays the subscription to the source Observable by a given
        amount, waiting and subscribing on the given Scheduler
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#delaySubscription" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delaySubscription(delay:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="delaySubscription(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delaySubscription</span><span class="params">(<span name="delay">delay: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return an Observable that delays the subscription to the source Observable by a given amount of time.</p><div class="fullcomment"><div class="comment cmt"><p>Return an Observable that delays the subscription to the source Observable by a given amount of time.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/delaySubscription.png">
</p></div><dl class="paramcmts block"><dt class="param">delay</dt><dd class="cmt"><p>the time to delay the subscription</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that delays the subscription to the source Observable by the given amount
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#dematerialize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dematerialize[U]:rx.lang.scala.Observable[U]"></a>
      <a id="dematerialize[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dematerialize</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.dematerialize.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Returns an Observable that reverses the effect of <a href="#materialize:rx.lang.scala.Observable[rx.lang.scala.Notification[T]]" class="extmbr" name="rx.lang.scala.Observable#materialize">rx.lang.scala.Observable.materialize</a> by
transforming the <a href="Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects emitted by the source Observable into the items
or notifications they represent.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Returns an Observable that reverses the effect of <a href="#materialize:rx.lang.scala.Observable[rx.lang.scala.Notification[T]]" class="extmbr" name="rx.lang.scala.Observable#materialize">rx.lang.scala.Observable.materialize</a> by
transforming the <a href="Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects emitted by the source Observable into the items
or notifications they represent.</p><p>This operation is only available if <code>this</code> is of type <code>Observable[Notification[U]]</code> for some <code>U</code>,
otherwise you will get a compilation error.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/dematerialize.png"></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items and notifications embedded in the <a href="Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects emitted by the source Observable</p></dd></dl><dl class="attributes block"> <div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dematerialize</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>], <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="Notification.html" class="extype" name="rx.lang.scala.Notification">Notification</a>[<span class="extype" name="rx.lang.scala.Observable.dematerialize.U">U</span>]]]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.dematerialize.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#distinct" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinct[U](keySelector:T=&gt;U):rx.lang.scala.Observable[T]"></a>
      <a id="distinct[U]((T)⇒U):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinct</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.distinct.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all items emitted from the source Observable that are distinct according
to a key selector function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all items emitted from the source Observable that are distinct according
to a key selector function.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.key.png">
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>
           a function that projects an emitted item to a key value which is used for deciding whether an item is
           distinct from another one or not</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable of distinct items
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#distinct" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinct:rx.lang.scala.Observable[T]"></a>
      <a id="distinct:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinct</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all distinct items emitted from the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all distinct items emitted from the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinct.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable of distinct items
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#distinctUntilChanged" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinctUntilChanged[U](keySelector:T=&gt;U):rx.lang.scala.Observable[T]"></a>
      <a id="distinctUntilChanged[U]((T)⇒U):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinctUntilChanged</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.distinctUntilChanged.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all items emitted from the source Observable that are sequentially
distinct according to a key selector function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all items emitted from the source Observable that are sequentially
distinct according to a key selector function.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.key.png">
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>
           a function that projects an emitted item to a key value which is used for deciding whether an item is sequentially
           distinct from another one or not</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable of sequentially distinct items
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#distinctUntilChanged" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="distinctUntilChanged:rx.lang.scala.Observable[T]"></a>
      <a id="distinctUntilChanged:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">distinctUntilChanged</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that forwards all sequentially distinct items emitted from the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that forwards all sequentially distinct items emitted from the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/distinctUntilChanged.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable of sequentially distinct items
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnCompleted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnCompleted(onCompleted:()=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnCompleted(()⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnCompleted</span><span class="params">(<span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Invokes an action when the source Observable calls <code>onCompleted</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Invokes an action when the source Observable calls <code>onCompleted</code>.
</p></div><dl class="paramcmts block"><dt class="param">onCompleted</dt><dd class="cmt"><p>the action to invoke when the source Observable calls
                   <code>onCompleted</code></p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable with the side-effecting behavior applied
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,onCompleted:()=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach((T)⇒Unit,(Throwable)⇒Unit,()⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>this function will be called if an error occurs</p></dd><dt class="param">onCompleted</dt><dd class="cmt"><p>the action to invoke when the source Observable calls
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach((T)⇒Unit,(Throwable)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>this function will be called if an error occurs
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(onNext:T=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach((T)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>this function will be called whenever the Observable emits an item
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnEach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnEach(observer:rx.lang.scala.Observer[T]):rx.lang.scala.Observable[T]"></a>
      <a id="doOnEach(Observer[T]):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnEach</span><span class="params">(<span name="observer">observer: <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable.
</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>the observer
</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the side-effecting behavior applied.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnError(onError:Throwable=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnError((Throwable)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnError</span><span class="params">(<span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Invokes an action if the source Observable calls <code>onError</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Invokes an action if the source Observable calls <code>onError</code>.
</p></div><dl class="paramcmts block"><dt class="param">onError</dt><dd class="cmt"><p>the action to invoke if the source Observable calls
               <code>onError</code></p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable with the side-effecting behavior applied
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#doOnNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doOnNext(onNext:T=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="doOnNext((T)⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doOnNext</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Invokes an action when the source Observable calls <code>onNext</code>.</code></p><div class="fullcomment"><div class="comment cmt"><p>Invokes an action when the source Observable calls <code>onNext</code>.
</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>the action to invoke when the source Observable calls <code>onNext</code></p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable with the side-effecting behavior applied
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#drop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="drop(time:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="drop(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="time">time: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that drops values emitted by the source Observable before a specified time window
elapses.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that drops values emitted by the source Observable before a specified time window
elapses.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skip.t.png">
</p></div><dl class="paramcmts block"><dt class="param">time</dt><dd class="cmt"><p>the length of the time window to drop</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>the <code>Scheduler</code> on which the timed wait happens</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that drops values emitted by the source Observable before the time window defined
        by <code>time</code> elapses and emits the remainder
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#drop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="drop(time:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="drop(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="time">time: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that drops values emitted by the source Observable before a specified time window
elapses.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that drops values emitted by the source Observable before a specified time window
elapses.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skip.t.png">
</p></div><dl class="paramcmts block"><dt class="param">time</dt><dd class="cmt"><p>the length of the time window to drop</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that drops values emitted by the source Observable before the time window defined
        by <code>time</code> elapses and emits the remainder
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#drop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="drop(n:Int):rx.lang.scala.Observable[T]"></a>
      <a id="drop(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="n">n: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that skips the first <code>num</code> items emitted by the source
Observable and emits the remainder.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that skips the first <code>num</code> items emitted by the source
Observable and emits the remainder.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skip.png">
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>
           the number of items to skip</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that is identical to the source Observable except that it does not
        emit the first <code>num</code> items that the source emits
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#dropRight" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropRight(time:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="dropRight(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropRight</span><span class="params">(<span name="time">time: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that drops items emitted by the source Observable during a specified time window
(defined on a specified scheduler) before the source completes.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that drops items emitted by the source Observable during a specified time window
(defined on a specified scheduler) before the source completes.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipLast.ts.png"></p><p>Note: this action will cache the latest items arriving in the specified time window.
</p></div><dl class="paramcmts block"><dt class="param">time</dt><dd class="cmt"><p>the length of the time window</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>the scheduler used as the time source</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that drops those items emitted by the source Observable in a time window before the
        source completes defined by <code>time</code> and <code>scheduler</code>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#dropRight" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropRight(time:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="dropRight(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropRight</span><span class="params">(<span name="time">time: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that drops items emitted by the source Observable during a specified time window
before the source completes.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that drops items emitted by the source Observable during a specified time window
before the source completes.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipLast.t.png"></p><p>Note: this action will cache the latest items arriving in the specified time window.
</p></div><dl class="paramcmts block"><dt class="param">time</dt><dd class="cmt"><p>the length of the time window</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that drops those items emitted by the source Observable in a time window before the
        source completes defined by <code>time</code>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#dropRight" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropRight(n:Int):rx.lang.scala.Observable[T]"></a>
      <a id="dropRight(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropRight</span><span class="params">(<span name="n">n: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that drops a specified number of items from the end of the sequence emitted by the
source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that drops a specified number of items from the end of the sequence emitted by the
source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipLast.png"></p><p>This Observer accumulates a queue long enough to store the first <code>n</code> items. As more items are
received, items are taken from the front of the queue and emitted by the returned Observable. This causes
such items to be delayed.
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>number of items to drop from the end of the source sequence</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items emitted by the source Observable except for the dropped ones
        at the end</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">IndexOutOfBoundsException<p>if <code>n</code> is less than zero
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#dropWhile" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dropWhile(predicate:T=&gt;Boolean):rx.lang.scala.Observable[T]"></a>
      <a id="dropWhile((T)⇒Boolean):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dropWhile</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that bypasses all items from the source Observable as long as the specified
condition holds true.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that bypasses all items from the source Observable as long as the specified
condition holds true. Emits all further source items as soon as the condition becomes false.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/skipWhile.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           A function to test each item emitted from the source Observable for a condition.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits all items from the source Observable as soon as the condition
        becomes false.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#elementAt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="elementAt(index:Int):rx.lang.scala.Observable[T]"></a>
      <a id="elementAt(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elementAt</span><span class="params">(<span name="index">index: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
source Observbable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the single item at a specified index in a sequence of emissions from a
source Observbable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/elementAt.png">
</p></div><dl class="paramcmts block"><dt class="param">index</dt><dd class="cmt"><p>
           the zero-based index of the item to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item: the item at the specified position in the sequence of
        those emitted by the source Observable</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">IndexOutOfBoundsException<p>
            if index is less than 0
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#elementAtOrDefault" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="elementAtOrDefault[U&gt;:T](index:Int,default:U):rx.lang.scala.Observable[U]"></a>
      <a id="elementAtOrDefault[U&gt;:T](Int,U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elementAtOrDefault</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="index">index: <span class="extype" name="scala.Int">Int</span></span>, <span name="default">default: <span class="extype" name="rx.lang.scala.Observable.elementAtOrDefault.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.elementAtOrDefault.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the item found at a specified index in a sequence of emissions from a
source Observable, or a default item if that index is out of range.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the item found at a specified index in a sequence of emissions from a
source Observable, or a default item if that index is out of range.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/elementAtOrDefault.png">
</p></div><dl class="paramcmts block"><dt class="param">index</dt><dd class="cmt"><p>
           the zero-based index of the item to retrieve</p></dd><dt class="param">default</dt><dd class="cmt"><p>
           the default item</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the item at the specified position in the sequence emitted by the source
        Observable, or the default item if that index is outside the bounds of the source sequence</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">IndexOutOfBoundsException<p>
            if <code> index</code> is less than 0
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#exists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="exists(p:T=&gt;Boolean):rx.lang.scala.Observable[Boolean]"></a>
      <a id="exists((T)⇒Boolean):Observable[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exists</span><span class="params">(<span name="p">p: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Tests whether a predicate holds for some of the elements of this <code>Observable</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Tests whether a predicate holds for some of the elements of this <code>Observable</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the predicate used to test elements.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable emitting one single Boolean, which is <code>true</code> if the given predicate <code>p</code>
                holds for some of the elements of this Observable, and <code>false</code> otherwise.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#filter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="filter(predicate:T=&gt;Boolean):rx.lang.scala.Observable[T]"></a>
      <a id="filter((T)⇒Boolean):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable which only emits those items for which a given predicate holds.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable which only emits those items for which a given predicate holds.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/filter.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           a function that evaluates the items emitted by the source Observable, returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only those items in the original Observable that the filter
        evaluates as <code>true</code>
</p></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="rx.lang.scala.Observable#finallyDo" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finallyDo(action:()=&gt;Unit):rx.lang.scala.Observable[T]"></a>
      <a id="finallyDo(()⇒Unit):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finallyDo</span><span class="params">(<span name="action">action: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Registers an function to be called when this Observable invokes <a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> or <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Registers an function to be called when this Observable invokes <a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> or <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/finallyDo.png">
</p></div><dl class="paramcmts block"><dt class="param">action</dt><dd class="cmt"><p>
           an function to be invoked when the source Observable finishes</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the same items as the source Observable, then invokes the function
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#first" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="first:rx.lang.scala.Observable[T]"></a>
      <a id="first:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">first</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the very first item emitted by the source Observable, or raises an
<code>NoSuchElementException</code> if the source Observable is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the very first item emitted by the source Observable, or raises an
<code>NoSuchElementException</code> if the source Observable is empty.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/first.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the very first item emitted by the source Observable, or raises an
        <code>NoSuchElementException</code> if the source Observable is empty</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>&quot;MSDN: Observable.firstAsync()&quot;
</p></span><span class="cmt"><p><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#wiki-first">RxJava Wiki: first()</a></p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#firstOrElse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="firstOrElse[U&gt;:T](default:=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="firstOrElse[U&gt;:T](⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">firstOrElse</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="default">default: ⇒ <span class="extype" name="rx.lang.scala.Observable.firstOrElse.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.firstOrElse.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">
</p></div><dl class="paramcmts block"><dt class="param">default</dt><dd class="cmt"><p>
           The default value to emit if the source Observable doesn't emit anything.
           This is a by-name parameter, so it is only evaluated if the source Observable doesn't emit anything.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the very first item from the source, or a default value
        if the source Observable completes without emitting any item.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#flatMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMap[R](f:T=&gt;rx.lang.scala.Observable[R]):rx.lang.scala.Observable[R]"></a>
      <a id="flatMap[R]((T)⇒Observable[R]):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatMap.R">R</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatMap.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new Observable by applying a function that you supply to each item emitted by
the source Observable, where that function returns an Observable, and then merging those
resulting Observables and emitting the results of this merger.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new Observable by applying a function that you supply to each item emitted by
the source Observable, where that function returns an Observable, and then merging those
resulting Observables and emitting the results of this merger.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png">
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>
           a function that, when applied to an item emitted by the source Observable, returns
           an Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the result of applying the transformation function to each
        item emitted by the source Observable and merging the results of the Observables
        obtained from this transformation.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#flatten" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatten[U]:rx.lang.scala.Observable[U]"></a>
      <a id="flatten[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatten</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatten.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Flattens the sequence of Observables emitted by <code>this</code> into one Observable, without any
transformation.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Flattens the sequence of Observables emitted by <code>this</code> into one Observable, without any
transformation.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png"></p><p>You can combine the items emitted by multiple Observables so that they act like a single
Observable by using this method.</p><p>This operation is only available if <code>this</code> is of type <code>Observable[Observable[U]]</code> for some <code>U</code>,
otherwise you'll get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of flattening the items emitted
        by the Observables emitted by <code>this</code></p></dd></dl><dl class="attributes block"> <div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatten</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>], <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatten.U">U</span>]]]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flatten.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#flattenDelayError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flattenDelayError[U]:rx.lang.scala.Observable[U]"></a>
      <a id="flattenDelayError[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flattenDelayError</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flattenDelayError.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] This behaves like <code>flatten</code> except that if any of the merged Observables
notify of an error via <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, this method will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>This behaves like <code>flatten</code> except that if any of the merged Observables
notify of an error via <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, this method will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png"></p><p>Even if multiple merged Observables send <code>onError</code> notifications, this method will only invoke the <code>onError</code> method of its
Observers once.</p><p>This method allows an Observer to receive all successfully emitted items from all of the
source Observables without being interrupted by an error notification from one of them.</p><p>This operation is only available if <code>this</code> is of type <code>Observable[Observable[U]]</code> for some <code>U</code>,
otherwise you'll get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of flattening the items emitted by
        the Observables emitted by the this Observable</p></dd></dl><dl class="attributes block"> <div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flattenDelayError</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>], <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flattenDelayError.U">U</span>]]]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.flattenDelayError.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#foldLeft" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldLeft[R](initialValue:R)(accumulator:(R,T)=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="foldLeft[R](R)((R,T)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldLeft</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="initialValue">initialValue: <span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span></span>)</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span>, <span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.foldLeft.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the final result from the final call to your function as its sole
item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the final result from the final call to your function as its sole
item.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/reduceSeed.png"></p><p>This technique, which is called &quot;reduce&quot; or &quot;aggregate&quot; here, is sometimes called &quot;fold,&quot;
&quot;accumulate,&quot; &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance,
has an <code>inject</code> method that does a similar operation on lists.
</p></div><dl class="paramcmts block"><dt class="param">initialValue</dt><dd class="cmt"><p>
           the initial (seed) accumulator value</p></dd><dt class="param">accumulator</dt><dd class="cmt"><p>
           an accumulator function to be invoked on each item emitted by the source
           Observable, the result of which will be used in the next accumulator call</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item that is the result of accumulating the output
        from the items emitted by the source Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#forall" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="forall(predicate:T=&gt;Boolean):rx.lang.scala.Observable[Boolean]"></a>
      <a id="forall((T)⇒Boolean):Observable[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">forall</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits a Boolean that indicates whether all of the items emitted by
the source Observable satisfy a condition.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits a Boolean that indicates whether all of the items emitted by
the source Observable satisfy a condition.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/all.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           a function that evaluates an item and returns a Boolean</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits <code>true</code> if all items emitted by the source
        Observable satisfy the predicate; otherwise, <code>false</code>
</p></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#groupBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="groupBy[K](f:T=&gt;K):rx.lang.scala.Observable[(K,rx.lang.scala.Observable[T])]"></a>
      <a id="groupBy[K]((T)⇒K):Observable[(K,Observable[T])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.groupBy.K">K</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.Observable.groupBy.K">K</span>, <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Groups the items emitted by this Observable according to a specified discriminator function.</p><div class="fullcomment"><div class="comment cmt"><p>Groups the items emitted by this Observable according to a specified discriminator function.
</p></div><dl class="paramcmts block"><dt class="tparam">K</dt><dd class="cmt"><p>
           the type of keys returned by the discriminator function.</p></dd><dt class="param">f</dt><dd class="cmt"><p>
           a function that extracts the key from an item</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits <code>(key, observable)</code> pairs, where <code>observable</code>
        contains all items for which <code>f</code> returned <code>key</code>.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#groupByUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="groupByUntil[K](f:T=&gt;K,closings:(K,rx.lang.scala.Observable[T])=&gt;rx.lang.scala.Observable[Any]):rx.lang.scala.Observable[(K,rx.lang.scala.Observable[T])]"></a>
      <a id="groupByUntil[K]((T)⇒K,(K,Observable[T])⇒Observable[Any]):Observable[(K,Observable[T])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">groupByUntil</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.groupByUntil.K">K</span></span>, <span name="closings">closings: (<span class="extype" name="rx.lang.scala.Observable.groupByUntil.K">K</span>, <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.Observable.groupByUntil.K">K</span>, <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Groups the items emitted by this Observable according to a specified discriminator function and terminates these groups
according to a function.</p><div class="fullcomment"><div class="comment cmt"><p>Groups the items emitted by this Observable according to a specified discriminator function and terminates these groups
according to a function.
</p></div><dl class="paramcmts block"><dt class="tparam">K</dt><dd class="cmt"><p>
           the type of the keys returned by the discriminator function.</p></dd><dt class="param">f</dt><dd class="cmt"><p>
           a function that extracts the key from an item</p></dd><dt class="param">closings</dt><dd class="cmt"><p>
           the function that accepts the key of a given group and an observable representing that group, and returns
           an observable that emits a single Closing when the group should be closed.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits <code>(key, observable)</code> pairs, where <code>observable</code>
        contains all items for which <code>f</code> returned <code>key</code> before <code>closings</code> emits a value.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#head" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="head:rx.lang.scala.Observable[T]"></a>
      <a id="head:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">head</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the very first item emitted by the source Observable, or raises an
<code>NoSuchElementException</code> if the source Observable is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the very first item emitted by the source Observable, or raises an
<code>NoSuchElementException</code> if the source Observable is empty.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/first.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the very first item emitted by the source Observable, or raises an
        <code>NoSuchElementException</code> if the source Observable is empty</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="#first:rx.lang.scala.Observable[T]" class="extmbr" name="rx.lang.scala.Observable#first">Observable.first</a>
</p></span><span class="cmt"><p>&quot;MSDN: Observable.firstAsync()&quot;</p></span><span class="cmt"><p><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observables#wiki-first">RxJava Wiki: first()</a></p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#headOrElse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="headOrElse[U&gt;:T](default:=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="headOrElse[U&gt;:T](⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headOrElse</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="default">default: ⇒ <span class="extype" name="rx.lang.scala.Observable.headOrElse.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.headOrElse.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the very first item emitted by the source Observable, or
a default value if the source Observable is empty.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/firstOrDefault.png">
</p></div><dl class="paramcmts block"><dt class="param">default</dt><dd class="cmt"><p>
           The default value to emit if the source Observable doesn't emit anything.
           This is a by-name parameter, so it is only evaluated if the source Observable doesn't emit anything.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the very first item from the source, or a default value
        if the source Observable completes without emitting any item.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#isEmpty" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isEmpty:rx.lang.scala.Observable[Boolean]"></a>
      <a id="isEmpty:Observable[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isEmpty</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Tests whether this <code>Observable</code> emits no elements.</p><div class="fullcomment"><div class="comment cmt"><p>Tests whether this <code>Observable</code> emits no elements.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting one single Boolean, which is <code>true</code> if this <code>Observable</code>
                emits no elements, and <code>false</code> otherwise.
</p></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#join" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="join[S,R](other:rx.lang.scala.Observable[S],leftDurationSelector:T=&gt;rx.lang.scala.Observable[Any],rightDurationSelector:S=&gt;rx.lang.scala.Observable[Any],resultSelector:(T,S)=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="join[S,R](Observable[S],(T)⇒Observable[Any],(S)⇒Observable[Any],(T,S)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">join</span><span class="tparams">[<span name="S">S</span>, <span name="R">R</span>]</span><span class="params">(<span name="other">other: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.join.S">S</span>]</span>, <span name="leftDurationSelector">leftDurationSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="rightDurationSelector">rightDurationSelector: (<span class="extype" name="rx.lang.scala.Observable.join.S">S</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="resultSelector">resultSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>, <span class="extype" name="rx.lang.scala.Observable.join.S">S</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.join.R">R</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.join.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Correlates the items emitted by two Observables based on overlapping durations.</p><div class="fullcomment"><div class="comment cmt"><p>Correlates the items emitted by two Observables based on overlapping durations.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/join_.png">
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>
         the second Observable to join items from</p></dd><dt class="param">leftDurationSelector</dt><dd class="cmt"><p>
         a function to select a duration for each item emitted by the source Observable,
         used to determine overlap</p></dd><dt class="param">rightDurationSelector</dt><dd class="cmt"><p>
        a function to select a duration for each item emitted by the inner Observable,
        used to determine overlap</p></dd><dt class="param">resultSelector</dt><dd class="cmt"><p>
        a function that computes an item to be emitted by the resulting Observable for any
        two overlapping items emitted by the two Observables</p></dd><dt>returns</dt><dd class="cmt"><p>
        an Observable that emits items correlating to items emitted by the source Observables
        that have overlapping durations</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="http://msdn.microsoft.com/en-us/library/hh229750.aspx">MSDN: Observable.Join</a>
</p></span><span class="cmt"><p><a href="https://github.com/Netflix/RxJava/wiki/Combining-Observables#join">RxJava Wiki: join()</a></p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#last" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="last:rx.lang.scala.Observable[T]"></a>
      <a id="last:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">last</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the last item emitted by the source Observable or notifies observers of
an <code>NoSuchElementException</code> if the source Observable is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the last item emitted by the source Observable or notifies observers of
an <code>NoSuchElementException</code> if the source Observable is empty.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/last.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits the last item from the source Observable or notifies observers of an
        error</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>&quot;MSDN: Observable.lastAsync()&quot;
</p></span><span class="cmt"><p><a href="https://github.com/Netflix/RxJava/wiki/Filtering-Observable-Operators#wiki-last">RxJava Wiki: last()</a></p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#length" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="length:rx.lang.scala.Observable[Int]"></a>
      <a id="length:Observable[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">length</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that counts the total number of elements in the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that counts the total number of elements in the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the number of counted elements of the source Observable
        as its single item.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#map" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[R](func:T=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="map[R]((T)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="func">func: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.map.R">R</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.map.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies the given function to each item emitted by an
Observable and emits the result.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies the given function to each item emitted by an
Observable and emits the result.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/map.png">
</p></div><dl class="paramcmts block"><dt class="param">func</dt><dd class="cmt"><p>
           a function to apply to each item emitted by the Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items from the source Observable, transformed by the
        given function
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#materialize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="materialize:rx.lang.scala.Observable[rx.lang.scala.Notification[T]]"></a>
      <a id="materialize:Observable[Notification[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">materialize</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="Notification.html" class="extype" name="rx.lang.scala.Notification">Notification</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Turns all of the notifications from a source Observable into <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> emissions,
and marks them with their original notification types within <a href="Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects.</p><div class="fullcomment"><div class="comment cmt"><p>Turns all of the notifications from a source Observable into <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> emissions,
and marks them with their original notification types within <a href="Notification.html" class="extype" name="rx.lang.scala.Notification">rx.lang.scala.Notification</a> objects.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/materialize.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable whose items are the result of materializing the items and
        notifications of the source Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#merge" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="merge[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="merge[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">merge</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.merge.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.merge.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Flattens two Observables into one Observable, without any transformation.</p><div class="fullcomment"><div class="comment cmt"><p>Flattens two Observables into one Observable, without any transformation.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/merge.png"></p><p>You can combine items emitted by two Observables so that they act like a single
Observable by using the <code>merge</code> method.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           an Observable to be merged</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits items from <code>this</code> and <code>that</code> until
           <code>this</code> or <code>that</code> emits <code>onError</code> or <code>onComplete</code>.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#mergeDelayError" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mergeDelayError[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="mergeDelayError[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mergeDelayError</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.mergeDelayError.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.mergeDelayError.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">This behaves like <a href="#merge[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]" class="extmbr" name="rx.lang.scala.Observable#merge">rx.lang.scala.Observable.merge</a> except that if any of the merged Observables
notify of an error via <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, <code>mergeDelayError</code> will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><div class="fullcomment"><div class="comment cmt"><p>This behaves like <a href="#merge[U&gt;:T](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]" class="extmbr" name="rx.lang.scala.Observable#merge">rx.lang.scala.Observable.merge</a> except that if any of the merged Observables
notify of an error via <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a>, <code>mergeDelayError</code> will
refrain from propagating that error notification until all of the merged Observables have
finished emitting items.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeDelayError.png"></p><p>Even if multiple merged Observables send <code>onError</code> notifications, <code>mergeDelayError</code> will only invoke the <code>onError</code> method of its
Observers once.</p><p>This method allows an Observer to receive all successfully emitted items from all of the
source Observables without being interrupted by an error notification from one of them.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>
           an Observable to be merged</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits items that are the result of flattening the items emitted by
        <code>this</code> and <code>that</code>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#multicast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="multicast[R&gt;:T](subject:rx.lang.scala.Subject[R]):(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[R])"></a>
      <a id="multicast[R&gt;:T](Subject[R]):(()⇒Subscription,Observable[R])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">multicast</span><span class="tparams">[<span name="R">R &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="subject">subject: <a href="Subject.html" class="extype" name="rx.lang.scala.Subject">Subject</a>[<span class="extype" name="rx.lang.scala.Observable.multicast.R">R</span>]</span>)</span><span class="result">: (() ⇒ <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a>, <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.multicast.R">R</span>])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that upon calling the start function causes the source Observable to
push results into the specified subject.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that upon calling the start function causes the source Observable to
push results into the specified subject.
</p></div><dl class="paramcmts block"><dt class="param">subject</dt><dd class="cmt"><p>
           the <code>rx.lang.scala.subjects.Subject</code> to push source items into</p></dd><dt>returns</dt><dd class="cmt"><p>a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> such that when the start function
        is called, the Observable starts to push results into the specified Subject
</p></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#observeOn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="observeOn(scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="observeOn(Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">observeOn</span><span class="params">(<span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronously notify <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s on the specified <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously notify <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s on the specified <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/observeOn.png">
</p></div><dl class="paramcmts block"><dt class="param">scheduler</dt><dd class="cmt"><p>
           the <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to notify <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s on</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified so that its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s are notified on the
        specified <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onErrorResumeNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorResumeNext[U&gt;:T](resumeSequence:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="onErrorResumeNext[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorResumeNext</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="resumeSequence">resumeSequence: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to pass control to another Observable rather than invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to pass control to another Observable rather than invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass
another Observable (<code>resumeSequence</code>) to an Observable's
<code>onErrorResumeNext</code> method, if the original Observable encounters an error,
instead of invoking its Observer's <code>onError</code> method, it will instead relinquish
control to <code>resumeSequence</code> which will invoke the Observer's <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a>
method if it is able to do so. In such a case, because no
Observable necessarily invokes <code>onError</code>, the Observer may never know that an
error happened.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeSequence</dt><dd class="cmt"><p>
           a function that returns an Observable that will take over if the source Observable
           encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable, with appropriately modified behavior
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onErrorResumeNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorResumeNext[U&gt;:T](resumeFunction:Throwable=&gt;rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="onErrorResumeNext[U&gt;:T]((Throwable)⇒Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorResumeNext</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="resumeFunction">resumeFunction: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorResumeNext.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to pass control to another Observable rather than invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to pass control to another Observable rather than invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass a
function that returns an Observable (<code>resumeFunction</code>) to
<code>onErrorResumeNext</code>, if the original Observable encounters an error, instead of
invoking its Observer's <code>onError</code> method, it will instead relinquish control to
the Observable returned from <code>resumeFunction</code>, which will invoke the Observer's
<a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> method if it is able to do so. In such a case, because no
Observable necessarily invokes <code>onError</code>, the Observer may never know that an
error happened.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeFunction</dt><dd class="cmt"><p>
           a function that returns an Observable that will take over if the source Observable
           encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable, with appropriately modified behavior
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onErrorReturn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onErrorReturn[U&gt;:T](resumeFunction:Throwable=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="onErrorReturn[U&gt;:T]((Throwable)⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onErrorReturn</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="resumeFunction">resumeFunction: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.onErrorReturn.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onErrorReturn.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to emit an item (returned by a specified function) rather than
invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to emit an item (returned by a specified function) rather than
invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/onErrorReturn.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorReturn</code> method changes this behavior. If you pass a function
(<code>resumeFunction</code>) to an Observable's <code>onErrorReturn</code> method, if the
original Observable encounters an error, instead of invoking its Observer's
<code>onError</code> method, it will instead pass the return value of
<code>resumeFunction</code> to the Observer's <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> method.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeFunction</dt><dd class="cmt"><p>
           a function that returns an item that the new Observable will emit if the source
           Observable encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable with appropriately modified behavior
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#onExceptionResumeNext" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onExceptionResumeNext[U&gt;:T](resumeSequence:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="onExceptionResumeNext[U&gt;:T](Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onExceptionResumeNext</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="resumeSequence">resumeSequence: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onExceptionResumeNext.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.onExceptionResumeNext.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Instruct an Observable to pass control to another Observable rather than invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error of type <code>java.lang.Exception</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Instruct an Observable to pass control to another Observable rather than invoking <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> if it encounters an error of type <code>java.lang.Exception</code>.</p><p>This differs from <code>Observable.onErrorResumeNext</code> in that this one does not handle <code>java.lang.Throwable</code> or <code>java.lang.Error</code> but lets those continue through.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/onErrorResumeNext.png"></p><p>By default, when an Observable encounters an error that prevents it from emitting the
expected item to its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>, the Observable invokes its Observer's
<code>onError</code> method, and then quits without invoking any more of its Observer's
methods. The <code>onErrorResumeNext</code> method changes this behavior. If you pass
another Observable (<code>resumeSequence</code>) to an Observable's
<code>onErrorResumeNext</code> method, if the original Observable encounters an error,
instead of invoking its Observer's <code>onError</code> method, it will instead relinquish
control to <code>resumeSequence</code> which will invoke the Observer's <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a>
method if it is able to do so. In such a case, because no
Observable necessarily invokes <code>onError</code>, the Observer may never know that an
error happened.</p><p>You can use this to prevent errors from propagating or to supply fallback data should errors
be encountered.
</p></div><dl class="paramcmts block"><dt class="param">resumeSequence</dt><dd class="cmt"><p>
           a function that returns an Observable that will take over if the source Observable
           encounters an error</p></dd><dt>returns</dt><dd class="cmt"><p>the original Observable, with appropriately modified behavior
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#parallel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parallel[R](f:rx.lang.scala.Observable[T]=&gt;rx.lang.scala.Observable[R],scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[R]"></a>
      <a id="parallel[R]((Observable[T])⇒Observable[R],Scheduler):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parallel</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: (<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Perform work in parallel by sharding an <code>Observable[T]</code> on a <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.</p><div class="fullcomment"><div class="comment cmt"><p>Perform work in parallel by sharding an <code>Observable[T]</code> on a <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>
           a function that applies Observable operators to <code>Observable[T]</code> in parallel and returns an <code>Observable[R]</code></p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           a <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to perform the work on.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the output of the function executed on a <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#parallel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parallel[R](f:rx.lang.scala.Observable[T]=&gt;rx.lang.scala.Observable[R]):rx.lang.scala.Observable[R]"></a>
      <a id="parallel[R]((Observable[T])⇒Observable[R]):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parallel</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: (<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.parallel.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Perform work in parallel by sharding an <code>Observable[T]</code> on a
<span class="extype" name="rx.lang.scala.concurrency.Schedulers.threadPoolForComputation">computation</span>
<a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.</p><div class="fullcomment"><div class="comment cmt"><p>Perform work in parallel by sharding an <code>Observable[T]</code> on a
<span class="extype" name="rx.lang.scala.concurrency.Schedulers.threadPoolForComputation">computation</span>
<a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> and return an <code>Observable[R]</code> with the output.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>
           a function that applies Observable operators to <code>Observable[T]</code> in parallel and returns an <code>Observable[R]</code></p></dd><dt>returns</dt><dd class="cmt"><p>an Observable with the output of the function executed on a <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#product" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="product:rx.lang.scala.Observable[T]"></a>
      <a id="product:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">product</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Returns an Observable that multiplies up the elements of this Observable.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Returns an Observable that multiplies up the elements of this Observable.</p><p>This operation is only available if the elements of this Observable are numbers, otherwise
you will get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the product of all the elements of the source Observable
        as its single item.</p></dd></dl><dl class="attributes block"> <div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">product</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: <span class="extype" name="scala.Numeric">Numeric</span>[<span class="extype" name="rx.lang.scala.Observable.product.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.product.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#publish" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="publish:rx.lang.scala.observables.ConnectableObservable[T]"></a>
      <a id="publish:ConnectableObservable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">publish</span><span class="result">: <a href="observables/ConnectableObservable.html" class="extype" name="rx.lang.scala.observables.ConnectableObservable">ConnectableObservable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>, which waits until the start function is called before it begins emitting
items to those <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s that have subscribed to it.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>, which waits until the start function is called before it begins emitting
items to those <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s that have subscribed to it.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/publishConnect.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an <a href="observables/ConnectableObservable.html" class="extype" name="rx.lang.scala.observables.ConnectableObservable">rx.lang.scala.observables.ConnectableObservable</a>.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#reduce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduce[U&gt;:T](accumulator:(U,U)=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="reduce[U&gt;:T]((U,U)⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span>, <span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.reduce.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by the source Observable into the same function, and so on until all items have been emitted
by the source Observable, and emits the final result from the final call to your function as
its sole item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by the source Observable into the same function, and so on until all items have been emitted
by the source Observable, and emits the final result from the final call to your function as
its sole item.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/reduce.png"></p><p>This technique, which is called &quot;reduce&quot; or &quot;aggregate&quot; here, is sometimes called &quot;fold,&quot;
&quot;accumulate,&quot; &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance,
has an <code>inject</code> method that does a similar operation on lists.
</p></div><dl class="paramcmts block"><dt class="param">accumulator</dt><dd class="cmt"><p>
           An accumulator function to be invoked on each item emitted by the source
           Observable, whose result will be used in the next accumulator call</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item that is the result of accumulating the
        output from the source Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#replay" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="replay:(()=&gt;rx.lang.scala.Subscription,rx.lang.scala.Observable[T])"></a>
      <a id="replay:(()⇒Subscription,Observable[T])"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replay</span><span class="result">: (() ⇒ <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a>, <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>])</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that shares a single subscription to the underlying
Observable that will replay all of its items and notifications to any future <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> that shares a single subscription to the underlying
Observable that will replay all of its items and notifications to any future <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a pair of a start function and an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> such that when the start function
        is called, the Observable starts to emit items to its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#retry" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="retry():rx.lang.scala.Observable[T]"></a>
      <a id="retry():Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">retry</span><span class="params">()</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retry subscription to origin Observable whenever onError is called (infinite retry count).</p><div class="fullcomment"><div class="comment cmt"><p>Retry subscription to origin Observable whenever onError is called (infinite retry count).</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png"></p><p>If <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">rx.lang.scala.Observer.onError</a> is invoked the source Observable will be re-subscribed to.</p><p>Any <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">rx.lang.scala.Observer.onNext</a> calls received on each attempt will be emitted and concatenated together.</p><p>For example, if an Observable fails on first time but emits [1, 2] then succeeds the second time and
emits [1, 2, 3, 4, 5] then the complete output would be [1, 2, 1, 2, 3, 4, 5, onCompleted].</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Observable with retry logic.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#retry" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="retry(retryCount:Int):rx.lang.scala.Observable[T]"></a>
      <a id="retry(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">retry</span><span class="params">(<span name="retryCount">retryCount: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retry subscription to origin Observable upto given retry count.</p><div class="fullcomment"><div class="comment cmt"><p>Retry subscription to origin Observable upto given retry count.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/retry.png"></p><p>If <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">rx.lang.scala.Observer.onError</a> is invoked the source Observable will be re-subscribed to as many times as defined by retryCount.</p><p>Any <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">rx.lang.scala.Observer.onNext</a> calls received on each attempt will be emitted and concatenated together.</p><p>For example, if an Observable fails on first time but emits [1, 2] then succeeds the second time and
emits [1, 2, 3, 4, 5] then the complete output would be [1, 2, 1, 2, 3, 4, 5, onCompleted].
</p></div><dl class="paramcmts block"><dt class="param">retryCount</dt><dd class="cmt"><p>
           Number of retry attempts before failing.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable with retry logic.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#sample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sample(sampler:rx.lang.scala.Observable[Any]):rx.lang.scala.Observable[T]"></a>
      <a id="sample(Observable[Any]):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sample</span><span class="params">(<span name="sampler">sampler: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return an Observable that emits the results of sampling the items emitted by the source Observable
whenever the specified sampler Observable emits an item or completes.</p><div class="fullcomment"><div class="comment cmt"><p>Return an Observable that emits the results of sampling the items emitted by the source Observable
whenever the specified sampler Observable emits an item or completes.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sample.o.png">
</p></div><dl class="paramcmts block"><dt class="param">sampler</dt><dd class="cmt"><p>
           the Observable to use for sampling the source Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the results of sampling the items emitted by this Observable whenever
        the sampler Observable emits an item or completes
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#sample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sample(duration:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="sample(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sample</span><span class="params">(<span name="duration">duration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/sample.png">
</p></div><dl class="paramcmts block"><dt class="param">duration</dt><dd class="cmt"><p>the sampling rate</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           the <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when sampling</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the results of sampling the items emitted by the source
        Observable at the specified time interval
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#sample" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sample(duration:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="sample(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sample</span><span class="params">(<span name="duration">duration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the results of sampling the items emitted by the source
Observable at a specified time interval.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/sample.png">
</p></div><dl class="paramcmts block"><dt class="param">duration</dt><dd class="cmt"><p>the sampling rate</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the results of sampling the items emitted by the source
        Observable at the specified time interval
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#scan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scan[U&gt;:T](accumulator:(U,U)=&gt;U):rx.lang.scala.Observable[U]"></a>
      <a id="scan[U&gt;:T]((U,U)⇒U):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.scan.U">U</span>, <span class="extype" name="rx.lang.scala.Observable.scan.U">U</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.scan.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.scan.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the
first item emitted by a source Observable, then feeds the result of that
function along with the second item emitted by an Observable into the
same function, and so on until all items have been emitted by the source
Observable, emitting the result of each of these iterations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the
first item emitted by a source Observable, then feeds the result of that
function along with the second item emitted by an Observable into the
same function, and so on until all items have been emitted by the source
Observable, emitting the result of each of these iterations.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scan.png"></p></div><dl class="paramcmts block"><dt class="param">accumulator</dt><dd class="cmt"><p>
           an accumulator function to be invoked on each item emitted by the source
           Observable, whose result will be emitted to <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s via
           <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> and used in the next accumulator call.</p></dd><dt>returns</dt><dd class="cmt"><p>
        an Observable that emits the results of each call to the
        accumulator function
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#scan" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scan[R](initialValue:R)(accumulator:(R,T)=&gt;R):rx.lang.scala.Observable[R]"></a>
      <a id="scan[R](R)((R,T)⇒R):Observable[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="initialValue">initialValue: <span class="extype" name="rx.lang.scala.Observable.scan.R">R</span></span>)</span><span class="params">(<span name="accumulator">accumulator: (<span class="extype" name="rx.lang.scala.Observable.scan.R">R</span>, <span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.scan.R">R</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.scan.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the result of each of these iterations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that applies a function of your choosing to the first item emitted by a
source Observable, then feeds the result of that function along with the second item emitted
by an Observable into the same function, and so on until all items have been emitted by the
source Observable, emitting the result of each of these iterations.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/scanSeed.png"></p><p>This sort of function is sometimes called an accumulator.</p><p>Note that when you pass a seed to <code>scan()</code> the resulting Observable will emit
that seed as its first emitted item.
</p></div><dl class="paramcmts block"><dt class="param">initialValue</dt><dd class="cmt"><p>
           the initial (seed) accumulator value</p></dd><dt class="param">accumulator</dt><dd class="cmt"><p>
           an accumulator function to be invoked on each item emitted by the source
           Observable, whose result will be emitted to <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s via
           <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> and used in the next accumulator call.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the results of each call to the accumulator function
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#serialize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="serialize:rx.lang.scala.Observable[T]"></a>
      <a id="serialize:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">serialize</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps this Observable in another Observable that ensures that the resulting
Observable is chronologically well-behaved.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps this Observable in another Observable that ensures that the resulting
Observable is chronologically well-behaved.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/synchronize.png"></p><p>A well-behaved Observable does not interleave its invocations of the <a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a>, <a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a>, and <a href="Observer.html#onError(error:Throwable):Unit" class="extmbr" name="rx.lang.scala.Observer#onError">onError</a> methods of
its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s; it invokes <code>onCompleted</code> or <code>onError</code> only once; and it never invokes <code>onNext</code> after invoking either <code>onCompleted</code> or <code>onError</code>.
<code>synchronize</code> enforces this, and the Observable it returns invokes <code>onNext</code> and <code>onCompleted</code> or <code>onError</code> synchronously.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that is a chronologically well-behaved version of the source
        Observable, and that synchronously notifies its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>s
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#single" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="single:rx.lang.scala.Observable[T]"></a>
      <a id="single:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">single</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">If the source Observable completes after emitting a single item, return an Observable that emits that
item.</p><div class="fullcomment"><div class="comment cmt"><p>If the source Observable completes after emitting a single item, return an Observable that emits that
item. If the source Observable emits more than one item or no items, throw an <code>NoSuchElementException</code>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/single.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits the single item emitted by the source Observable</p></dd></dl><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">NoSuchElementException<p>
            if the source emits more than one item or no items</p></span></dd><dt>See also</dt><dd><span class="cmt"><p>&quot;MSDN: Observable.singleAsync()&quot;
</p></span><span class="cmt"><p><a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#wiki-single-and-singleordefault">RxJava Wiki: single()</a></p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#size" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="size:rx.lang.scala.Observable[Int]"></a>
      <a id="size:Observable[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">size</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that counts the total number of elements in the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that counts the total number of elements in the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the number of counted elements of the source Observable
        as its single item.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the scheduler to use
</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit,Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the scheduler to use
</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,onCompleted:()=&gt;Unit,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit,()⇒Unit,Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt class="param">onCompleted</dt><dd class="cmt"><p>
        this function will be called when this Observable has finished emitting items</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the scheduler to use
</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit,onCompleted:()=&gt;Unit):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit,()⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onCompleted">onCompleted: () ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt class="param">onCompleted</dt><dd class="cmt"><p>
        this function will be called when this Observable has finished emitting items</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit,onError:Throwable=&gt;Unit):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit,(Throwable)⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="onError">onError: (<span class="extype" name="scala.Throwable">Throwable</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items and notifications from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items and notifications from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt class="param">onError</dt><dd class="cmt"><p>
        this function will be called if an error occurs</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(onNext:T=&gt;Unit):rx.lang.scala.Subscription"></a>
      <a id="subscribe((T)⇒Unit):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="onNext">onNext: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to receive items from this observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to receive items from this observable.</p></div><dl class="paramcmts block"><dt class="param">onNext</dt><dd class="cmt"><p>
        this function will be called whenever the Observable emits an item</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(observer:rx.lang.scala.Observer[T]):rx.lang.scala.Subscription"></a>
      <a id="subscribe(Observer[T]):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="observer">observer: <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>
        the observer</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(observer:rx.lang.scala.Observer[T],scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Subscription"></a>
      <a id="subscribe(Observer[T],Scheduler):Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="observer">observer: <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">Observer</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt class="param">observer</dt><dd class="cmt"><p>
        the observer</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
        the <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> on which Observers subscribe to the Observable</p></dd><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribe" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe():rx.lang.scala.Subscription"></a>
      <a id="subscribe():Subscription"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">()</span><span class="result">: <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">Subscription</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Call this method to subscribe an <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a> for receiving
items and notifications from the Observable.</p><p>A typical implementation of <code>subscribe</code> does the following:</p><p>It stores a reference to the Observer in a collection object, such as a <code>List[T]</code> object.</p><p>It returns a reference to the <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> interface. This enables Observers to
unsubscribe, that is, to stop receiving items and notifications before the Observable stops
sending them, which also invokes the Observer's <a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a> method.</p><p>An <code>Observable[T]</code> instance is responsible for accepting all subscriptions
and notifying all Observers. Unless the documentation for a particular
<code>Observable[T]</code> implementation indicates otherwise, Observers should make no
assumptions about the order in which multiple Observers will receive their notifications.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>
        a <a href="Subscription.html" class="extype" name="rx.lang.scala.Subscription">rx.lang.scala.Subscription</a> reference whose <code>unsubscribe</code> method can be called to  stop receiving items
        before the Observable has finished sending them</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#subscribeOn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribeOn(scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="subscribeOn(Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribeOn</span><span class="params">(<span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronously subscribes and unsubscribes Observers on the specified <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously subscribes and unsubscribes Observers on the specified <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/subscribeOn.png">
</p></div><dl class="paramcmts block"><dt class="param">scheduler</dt><dd class="cmt"><p>
           the <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to perform subscription and unsubscription actions on</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified so that its subscriptions and unsubscriptions happen
        on the specified <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#sum" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sum:rx.lang.scala.Observable[T]"></a>
      <a id="sum:Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sum</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Returns an Observable that sums up the elements of this Observable.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Returns an Observable that sums up the elements of this Observable.</p><p>This operation is only available if the elements of this Observable are numbers, otherwise
you will get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable emitting the sum of all the elements of the source Observable
        as its single item.</p></dd></dl><dl class="attributes block"> <div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sum</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: <span class="extype" name="scala.Numeric">Numeric</span>[<span class="extype" name="rx.lang.scala.Observable.sum.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.sum.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="rx.lang.scala.Observable#switch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="switch[U]:rx.lang.scala.Observable[U]"></a>
      <a id="switch[U]:Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">switch</span><span class="tparams">[<span name="U">U</span>]</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.switch.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">[use case] Given an Observable that emits Observables, creates a single Observable that
emits the items emitted by the most recently published of those Observables.</p><div class="fullcomment">[use case] <div class="comment cmt"><p>Given an Observable that emits Observables, creates a single Observable that
emits the items emitted by the most recently published of those Observables.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/switchDo.png"></p><p>This operation is only available if <code>this</code> is of type <code>Observable[Observable[U]]</code> for some <code>U</code>,
otherwise you'll get a compilation error.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the items emitted by the most recently published
        Observable</p></dd></dl><dl class="attributes block"> <div class="full-signature-block toggleContainer">
            <span class="toggle">Full Signature</span>
            <div class="hiddenContent full-signature-usecase"><h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">switch</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>], <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.switch.U">U</span>]]]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.switch.U">U</span>]</span>
      </span>
      </h4></div>
          </div></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="rx.lang.scala.Observable#take" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="take(n:Int):rx.lang.scala.Observable[T]"></a>
      <a id="take(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">take</span><span class="params">(<span name="n">n: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the first <code>num</code> items emitted by the source
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the first <code>num</code> items emitted by the source
Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/take.png"></p><p>This method returns an Observable that will invoke a subscribing <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>'s
<a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> function a maximum of <code>num</code> times before invoking
<a href="Observer.html#onCompleted():Unit" class="extmbr" name="rx.lang.scala.Observer#onCompleted">onCompleted</a>.
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>
           the number of items to take</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the first <code>num</code> items from the source
        Observable, or all of the items from the source Observable if that Observable emits
        fewer than <code>num</code> items
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#takeRight" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeRight(count:Int):rx.lang.scala.Observable[T]"></a>
      <a id="takeRight(Int):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeRight</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits only the last <code>count</code> items emitted by the source
Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the last <code>count</code> items emitted by the source
Observable.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/last.png">
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           the number of items to emit from the end of the sequence emitted by the source
           Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the last <code>count</code> items emitted by the source
        Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#takeUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeUntil[E](that:rx.lang.scala.Observable[E]):rx.lang.scala.Observable[T]"></a>
      <a id="takeUntil[E](Observable[E]):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeUntil</span><span class="tparams">[<span name="E">E</span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.takeUntil.E">E</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits the items from the source Observable only until the
<code>other</code> Observable emits an item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the items from the source Observable only until the
<code>other</code> Observable emits an item.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeUntil.png">
</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>
           the type of items emitted by <code>other</code></p></dd><dt class="param">that</dt><dd class="cmt"><p>
           the Observable whose first emitted item will cause <code>takeUntil</code> to stop
           emitting items from the source Observable</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items of the source Observable until such time as
        <code>other</code> emits its first item
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#takeWhile" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeWhile(predicate:T=&gt;Boolean):rx.lang.scala.Observable[T]"></a>
      <a id="takeWhile((T)⇒Boolean):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeWhile</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits items emitted by the source Observable so long as a
specified condition is true.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits items emitted by the source Observable so long as a
specified condition is true.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/takeWhile.png">
</p></div><dl class="paramcmts block"><dt class="param">predicate</dt><dd class="cmt"><p>
           a function that evaluates an item emitted by the source Observable and returns a
           Boolean</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits the items from the source Observable so long as each item
        satisfies the condition defined by <code>predicate</code>
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleFirst" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleFirst(skipDuration:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="throttleFirst(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleFirst</span><span class="params">(<span name="skipDuration">skipDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><p>This differs from <code>Observable.throttleLast</code> in that this only tracks passage of time whereas <code>Observable.throttleLast</code> ticks at scheduled intervals.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleFirst.png">
</p></div><dl class="paramcmts block"><dt class="param">skipDuration</dt><dd class="cmt"><p>
           Time to wait before sending another value after emitting last value.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleFirst" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleFirst(skipDuration:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="throttleFirst(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleFirst</span><span class="params">(<span name="skipDuration">skipDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by skipping value until <code>skipDuration</code> passes and then emits the next received value.</p><p>This differs from <code>Observable.throttleLast</code> in that this only tracks passage of time whereas <code>Observable.throttleLast</code> ticks at scheduled intervals.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleFirst.png">
</p></div><dl class="paramcmts block"><dt class="param">skipDuration</dt><dd class="cmt"><p>
           Time to wait before sending another value after emitting last value.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use internally to manage the timers which handle timeout for each event.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleLast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleLast(intervalDuration:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="throttleLast(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleLast</span><span class="params">(<span name="intervalDuration">intervalDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><p>This differs from <code>Observable.throttleFirst</code> in that this ticks along at a scheduled interval whereas <code>Observable.throttleFirst</code> does not tick, it just tracks passage of time.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleLast.png">
</p></div><dl class="paramcmts block"><dt class="param">intervalDuration</dt><dd class="cmt"><p>
           Duration of windows within with the last value will be chosen.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleLast" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleLast(intervalDuration:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="throttleLast(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleLast</span><span class="params">(<span name="intervalDuration">intervalDuration: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><div class="fullcomment"><div class="comment cmt"><p>Throttles by returning the last value of each interval defined by 'intervalDuration'.</p><p>This differs from <code>Observable.throttleFirst</code> in that this ticks along at a scheduled interval whereas <code>Observable.throttleFirst</code> does not tick, it just tracks passage of time.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleLast.png">
</p></div><dl class="paramcmts block"><dt class="param">intervalDuration</dt><dd class="cmt"><p>
           Duration of windows within with the last value will be chosen.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleWithTimeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleWithTimeout(timeout:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="throttleWithTimeout(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleWithTimeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleWithTimeout.png">
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use internally to manage the timers which handle timeout for each event.</p></dd><dt>returns</dt><dd class="cmt"><p>Observable which performs the throttle operation.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>Observable.debounce</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#throttleWithTimeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="throttleWithTimeout(timeout:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="throttleWithTimeout(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">throttleWithTimeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Debounces by dropping all values that are followed by newer values before the timeout value expires.</p><div class="fullcomment"><div class="comment cmt"><p>Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each <code>onNext</code> call.</p><p>NOTE: If events keep firing faster than the timeout then no data will be emitted.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/throttleWithTimeout.png"></p><p>Information on debounce vs throttle:</p><ul><li><a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank">http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</a></li><li><a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank">http://unscriptable.com/2009/03/20/debouncing-javascript-methods/</a></li><li><a href="http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/" target="_blank">http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/</a></li></ul></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>
           The time each value has to be 'the most recent' of the <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> to ensure that it's not dropped.
</p></dd><dt>returns</dt><dd class="cmt"><p>An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which filters out values which are too quickly followed up with newer values.</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><code>Observable.debounce</code>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout[U,V,O&gt;:T](firstTimeoutSelector:()=&gt;rx.lang.scala.Observable[U],timeoutSelector:T=&gt;rx.lang.scala.Observable[V],other:rx.lang.scala.Observable[O]):rx.lang.scala.Observable[O]"></a>
      <a id="timeout[U,V,O&gt;:T](()⇒Observable[U],(T)⇒Observable[V],Observable[O]):Observable[O]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="tparams">[<span name="U">U</span>, <span name="V">V</span>, <span name="O">O &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="firstTimeoutSelector">firstTimeoutSelector: () ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.U">U</span>]</span>, <span name="timeoutSelector">timeoutSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.V">V</span>]</span>, <span name="other">other: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.O">O</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.O">O</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that mirrors the source Observable, but switches to a fallback
Observable if either the first item emitted by the source Observable or any subsequent item
don't arrive within time windows defined by other Observables.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the source Observable, but switches to a fallback
Observable if either the first item emitted by the source Observable or any subsequent item
don't arrive within time windows defined by other Observables.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout6.png">
</p></div><dl class="paramcmts block"><dt class="param">firstTimeoutSelector</dt><dd class="cmt"><p>
           a function that returns an Observable which determines the timeout window for the
           first source item</p></dd><dt class="param">timeoutSelector</dt><dd class="cmt"><p>
           a function that returns an Observable for each item emitted by the source
           Observable and that determines the timeout window in which the subsequent source
           item must arrive in order to continue the sequence</p></dd><dt class="param">other</dt><dd class="cmt"><p>
           the fallback Observable to switch to if the source Observable times out</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that mirrors the source Observable, but switches to the <code> other</code> Observable if either the first item emitted by the source Observable or any
        subsequent item don't arrive within time windows defined by the timeout selectors
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout[U,V](firstTimeoutSelector:()=&gt;rx.lang.scala.Observable[U],timeoutSelector:T=&gt;rx.lang.scala.Observable[V]):rx.lang.scala.Observable[T]"></a>
      <a id="timeout[U,V](()⇒Observable[U],(T)⇒Observable[V]):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="tparams">[<span name="U">U</span>, <span name="V">V</span>]</span><span class="params">(<span name="firstTimeoutSelector">firstTimeoutSelector: () ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.U">U</span>]</span>, <span name="timeoutSelector">timeoutSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.V">V</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that mirrors the source Observable, but emits a TimeoutException
if either the first item emitted by the source Observable or any subsequent item
don't arrive within time windows defined by other Observables.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the source Observable, but emits a TimeoutException
if either the first item emitted by the source Observable or any subsequent item
don't arrive within time windows defined by other Observables.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout5.png">
</p></div><dl class="paramcmts block"><dt class="param">firstTimeoutSelector</dt><dd class="cmt"><p>
           a function that returns an Observable that determines the timeout window for the
           first source item</p></dd><dt class="param">timeoutSelector</dt><dd class="cmt"><p>
           a function that returns an Observable for each item emitted by the source
           Observable and that determines the timeout window in which the subsequent source
           item must arrive in order to continue the sequence</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that mirrors the source Observable, but emits a TimeoutException if either the first item or any subsequent item doesn't
        arrive within the time windows specified by the timeout selectors
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout[V,O&gt;:T](timeoutSelector:T=&gt;rx.lang.scala.Observable[V],other:rx.lang.scala.Observable[O]):rx.lang.scala.Observable[O]"></a>
      <a id="timeout[V,O&gt;:T]((T)⇒Observable[V],Observable[O]):Observable[O]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="tparams">[<span name="V">V</span>, <span name="O">O &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="timeoutSelector">timeoutSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.V">V</span>]</span>, <span name="other">other: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.O">O</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.O">O</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that mirrors the source Observable, but that switches to a fallback
Observable if an item emitted by the source Observable doesn't arrive within a window of time
after the emission of the previous item, where that period of time is measured by an
Observable that is a function of the previous item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the source Observable, but that switches to a fallback
Observable if an item emitted by the source Observable doesn't arrive within a window of time
after the emission of the previous item, where that period of time is measured by an
Observable that is a function of the previous item.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout4.png"></p><p>Note: The arrival of the first source item is never timed out.
</p></div><dl class="paramcmts block"><dt class="param">timeoutSelector</dt><dd class="cmt"><p>
           a function that returns an observable for each item emitted by the source
           Observable and that determines the timeout window for the subsequent item</p></dd><dt class="param">other</dt><dd class="cmt"><p>
           the fallback Observable to switch to if the source Observable times out</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that mirrors the source Observable, but switches to mirroring a
        fallback Observable if a item emitted by the source Observable takes longer to arrive
        than the time window defined by the selector for the previously emitted item
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout[V](timeoutSelector:T=&gt;rx.lang.scala.Observable[V]):rx.lang.scala.Observable[T]"></a>
      <a id="timeout[V]((T)⇒Observable[V]):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="tparams">[<span name="V">V</span>]</span><span class="params">(<span name="timeoutSelector">timeoutSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.V">V</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that mirrors the source Observable, but emits a TimeoutException if an item emitted by
the source Observable doesn't arrive within a window of time after the emission of the
previous item, where that period of time is measured by an Observable that is a function
of the previous item.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the source Observable, but emits a TimeoutException if an item emitted by
the source Observable doesn't arrive within a window of time after the emission of the
previous item, where that period of time is measured by an Observable that is a function
of the previous item.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout3.png"></p><p>Note: The arrival of the first source item is never timed out.
</p></div><dl class="paramcmts block"><dt class="param">timeoutSelector</dt><dd class="cmt"><p>
           a function that returns an observable for each item emitted by the source
           Observable and that determines the timeout window for the subsequent item</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that mirrors the source Observable, but emits a TimeoutException if a item emitted by
        the source Observable takes longer to arrive than the time window defined by the
        selector for the previously emitted item
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout[U&gt;:T](timeout:scala.concurrent.duration.Duration,other:rx.lang.scala.Observable[U],scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[U]"></a>
      <a id="timeout[U&gt;:T](Duration,Observable[U],Scheduler):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="other">other: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.U">U</span>]</span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers. If the next item isn't
observed within the specified timeout duration starting from its
predecessor, a specified fallback Observable sequence produces future
items and notifications from that point on.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.2s.png">
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration between items before a timeout occurs</p></dd><dt class="param">other</dt><dd class="cmt"><p>Observable to use as the fallback in case of a timeout</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>Scheduler to run the timeout timers on</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified so that it will switch to the
        fallback Observable in case of a timeout
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout(timeout:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[T]"></a>
      <a id="timeout(Duration,Scheduler):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers. If the next item isn't
observed within the specified timeout duration starting from its
predecessor, the observer is notified of a <code>TimeoutException</code>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.1s.png">
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration between items before a timeout occurs</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>Scheduler to run the timeout timers on</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified to notify observers of a
        <code>TimeoutException</code> in case of a timeout
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout[U&gt;:T](timeout:scala.concurrent.duration.Duration,other:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[U]"></a>
      <a id="timeout[U&gt;:T](Duration,Observable[U]):Observable[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="rx.lang.scala.Observable.T">T</span></span>]</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="other">other: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.timeout.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers. If the next item isn't
observed within the specified timeout duration starting from its
predecessor, a specified fallback Observable produces future items and
notifications from that point on.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.2.png">
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration between items before a timeout occurs</p></dd><dt class="param">other</dt><dd class="cmt"><p>fallback Observable to use in case of a timeout</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified to switch to the fallback
        Observable in case of a timeout
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout(timeout:scala.concurrent.duration.Duration):rx.lang.scala.Observable[T]"></a>
      <a id="timeout(Duration):Observable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a timeout policy for each item emitted by the Observable, using
the specified scheduler to run timeout timers. If the next item isn't
observed within the specified timeout duration starting from its
predecessor, observers are notified of a <code>TimeoutException</code>.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timeout.1.png">
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration between items before a timeout occurs</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable modified to notify observers of a
        <code>TimeoutException</code> in case of a timeout
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timestamp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timestamp(scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[(Long,T)]"></a>
      <a id="timestamp(Scheduler):Observable[(Long,T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timestamp</span><span class="params">(<span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="rx.lang.scala.Observable.T">T</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps each item emitted by a source Observable in a timestamped tuple
with timestamps provided by the given Scheduler.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps each item emitted by a source Observable in a timestamped tuple
with timestamps provided by the given Scheduler.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timestamp.s.png">
</p></div><dl class="paramcmts block"><dt class="param">scheduler</dt><dd class="cmt"><p><a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use as a time source.</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits timestamped items from the source
        Observable with timestamps provided by the given Scheduler
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#timestamp" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timestamp:rx.lang.scala.Observable[(Long,T)]"></a>
      <a id="timestamp:Observable[(Long,T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timestamp</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="rx.lang.scala.Observable.T">T</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps each item emitted by a source Observable in a timestamped tuple.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps each item emitted by a source Observable in a timestamped tuple.</p><p><img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/timestamp.png">
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits timestamped items from the source Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#toBlockingObservable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toBlockingObservable:rx.lang.scala.observables.BlockingObservable[T]"></a>
      <a id="toBlockingObservable:BlockingObservable[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toBlockingObservable</span><span class="result">: <a href="observables/BlockingObservable.html" class="extype" name="rx.lang.scala.observables.BlockingObservable">BlockingObservable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Converts an Observable into a <a href="observables/BlockingObservable.html" class="extype" name="rx.lang.scala.observables.BlockingObservable">rx.lang.scala.observables.BlockingObservable</a> (an Observable with blocking
operators).</p><div class="fullcomment"><div class="comment cmt"><p>Converts an Observable into a <a href="observables/BlockingObservable.html" class="extype" name="rx.lang.scala.observables.BlockingObservable">rx.lang.scala.observables.BlockingObservable</a> (an Observable with blocking
operators).
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="https://github.com/Netflix/RxJava/wiki/Blocking-Observable-Operators">Blocking Observable Operators</a>
</p></span></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#toMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toMap[K,V](keySelector:T=&gt;K,valueSelector:T=&gt;V,mapFactory:()=&gt;Map[K,V]):rx.lang.scala.Observable[Map[K,V]]"></a>
      <a id="toMap[K,V]((T)⇒K,(T)⇒V,()⇒Map[K,V]):Observable[Map[K,V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMap</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.toMap.K">K</span></span>, <span name="valueSelector">valueSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.toMap.V">V</span></span>, <span name="mapFactory">mapFactory: () ⇒ <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="rx.lang.scala.Observable.toMap.K">K</span>, <span class="extype" name="rx.lang.scala.Observable.toMap.V">V</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="rx.lang.scala.Observable.toMap.K">K</span>, <span class="extype" name="rx.lang.scala.Observable.toMap.V">V</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return an Observable that emits a single Map, returned by a specified <code> mapFactory</code> function, that
contains keys and values extracted from the items emitted by the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Return an Observable that emits a single Map, returned by a specified <code> mapFactory</code> function, that
contains keys and values extracted from the items emitted by the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMap.png">
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>
           the function that extracts the key from a source item to be used in the Map</p></dd><dt class="param">valueSelector</dt><dd class="cmt"><p>
           the function that extracts the value from the source items to be used as value in the Map</p></dd><dt class="param">mapFactory</dt><dd class="cmt"><p>
           the function that returns a Map instance to be used</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item: a Map that contains the mapped items emitted by the
        source Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#toMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toMap[K,V](keySelector:T=&gt;K,valueSelector:T=&gt;V):rx.lang.scala.Observable[Map[K,V]]"></a>
      <a id="toMap[K,V]((T)⇒K,(T)⇒V):Observable[Map[K,V]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMap</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.toMap.K">K</span></span>, <span name="valueSelector">valueSelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.toMap.V">V</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="rx.lang.scala.Observable.toMap.K">K</span>, <span class="extype" name="rx.lang.scala.Observable.toMap.V">V</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return an Observable that emits a single Map containing values corresponding to items emitted by the
source Observable, mapped by the keys returned by a specified <code> keySelector</code> function.</p><div class="fullcomment"><div class="comment cmt"><p>Return an Observable that emits a single Map containing values corresponding to items emitted by the
source Observable, mapped by the keys returned by a specified <code> keySelector</code> function.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMap.png"></p><p>If more than one source item maps to the same key, the Map will contain a single entry that
corresponds to the latest of those items.
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>
           the function that extracts the key from a source item to be used in the Map</p></dd><dt class="param">valueSelector</dt><dd class="cmt"><p>
           the function that extracts the value from a source item to be used in the Map</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item: a HashMap containing the mapped items from the source
        Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#toMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toMap[K](keySelector:T=&gt;K):rx.lang.scala.Observable[Map[K,T]]"></a>
      <a id="toMap[K]((T)⇒K):Observable[Map[K,T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toMap</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="rx.lang.scala.Observable.toMap.K">K</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="rx.lang.scala.Observable.toMap.K">K</span>, <span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return an Observable that emits a single Map containing all items emitted by the source Observable,
mapped by the keys returned by a specified <code> keySelector</code> function.</p><div class="fullcomment"><div class="comment cmt"><p>Return an Observable that emits a single Map containing all items emitted by the source Observable,
mapped by the keys returned by a specified <code> keySelector</code> function.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toMap.png"></p><p>If more than one source item maps to the same key, the Map will contain the latest of those items.
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>
the function that extracts the key from a source item to be used in the Map</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item: a Map containing the mapped items from the source
        Observable
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#toSeq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toSeq:rx.lang.scala.Observable[Seq[T]]"></a>
      <a id="toSeq:Observable[Seq[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toSeq</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable that emits a single item, a list composed of all the items emitted by
the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits a single item, a list composed of all the items emitted by
the source Observable.</p><p><img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/toList.png"></p><p>Normally, an Observable that returns multiple items will do so by invoking its <a href="Observer.html" class="extype" name="rx.lang.scala.Observer">rx.lang.scala.Observer</a>'s
<a href="Observer.html#onNext(value:T):Unit" class="extmbr" name="rx.lang.scala.Observer#onNext">onNext</a> method for each such item. You can change
this behavior, instructing the Observable to compose a list of all of these items and then to
invoke the Observer's <code>onNext</code> function once, passing it the entire list, by
calling the Observable's <code>toList</code> method prior to calling its <code>Observable.subscribe</code> method.</p><p>Be careful not to use this operator on Observables that emit infinite or very large numbers
of items, as you do not have the option to unsubscribe.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that emits a single item: a List containing all of the items emitted by
        the source Observable.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Duration,Scheduler):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable starts a new window
periodically, which is determined by the <code>timeshift</code> argument. Each window is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new window will be created.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new windows periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,timeshift:scala.concurrent.duration.Duration):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Duration):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="timeshift">timeshift: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable starts a new window
periodically, which is determined by the <code>timeshift</code> argument. Each window is emitted after a fixed timespan
specified by the <code>timespan</code> argument. When the source Observable completes or encounters an error, the
current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted.</p></dd><dt class="param">timeshift</dt><dd class="cmt"><p>
           The period of time after which a new window will be created.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces new windows periodically, and these are emitted after
        a fixed timespan has elapsed.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,count:Int,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Int,Scheduler):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows which are emitted after
        a fixed duration or when the window has reached maximum capacity (which ever occurs first).
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,count:Int):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Int):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument or a maximum size
specified by the <code>count</code> argument (which ever is reached first). When the source Observable completes
or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows which are emitted after
        a fixed duration or when the window has reached maximum capacity (which ever occurs first).
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration,scheduler:rx.lang.scala.Scheduler):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration,Scheduler):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>, <span name="scheduler">scheduler: <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">Scheduler</a></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument. When the source
Observable completes or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt class="param">scheduler</dt><dd class="cmt"><p>
           The <a href="Scheduler.html" class="extype" name="rx.lang.scala.Scheduler">rx.lang.scala.Scheduler</a> to use when determining the end and start of a window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows with a fixed duration.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(timespan:scala.concurrent.duration.Duration):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Duration):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="timespan">timespan: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each of a fixed duration specified by the <code>timespan</code> argument. When the source
Observable completes or encounters an error, the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>
           The period of time each window is collecting values before it should be emitted, and
           replaced with a new window.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows with a fixed duration.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(count:Int,skip:Int):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Int,Int):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>, <span name="skip">skip: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces windows every
<code>skip</code> values, each containing <code>count</code> elements. When the source Observable completes or encounters an error,
the current window is emitted and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt class="param">skip</dt><dd class="cmt"><p>
           How many produced values need to be skipped before starting a new window. Note that when <code>skip</code> and
           <code>count</code> are equal that this is the same operation as <code>window(int)</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces windows every <code>skip</code> values containing at most
        <code>count</code> produced values.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(count:Int):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(Int):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows, each containing <code>count</code> elements. When the source Observable completes or
encounters an error, the current window is emitted, and the event is propagated.
</p></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>
           The maximum size of each window before it should be emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows containing at most
        <code>count</code> produced values.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window[Opening](openings:rx.lang.scala.Observable[Opening],closings:Opening=&gt;rx.lang.scala.Observable[Any]):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window[Opening](Observable[Opening],(Opening)⇒Observable[Any]):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="tparams">[<span name="Opening">Opening</span>]</span><span class="params">(<span name="openings">openings: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.window.Opening">Opening</span>]</span>, <span name="closings">closings: (<span class="extype" name="rx.lang.scala.Observable.window.Opening">Opening</span>) ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. Chunks are created when the specified <code>openings</code>
Observable produces an object. That object is used to construct an Observable to emit windows, feeding it into <code>closings</code> function.
Windows are emitted when the created Observable produces an object.
</p></div><dl class="paramcmts block"><dt class="param">openings</dt><dd class="cmt"><p>
           The <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which when it produces an object, will cause
           another window to be created.</p></dd><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every window created.
           When this <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated window
           is emitted.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces windows which are created and emitted when the specified <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a>s publish certain objects.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#window" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="window(closings:()=&gt;rx.lang.scala.Observable[Any]):rx.lang.scala.Observable[rx.lang.scala.Observable[T]]"></a>
      <a id="window(()⇒Observable[Any]):Observable[Observable[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">window</span><span class="params">(<span name="closings">closings: () ⇒ <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates an Observable which produces windows of collected values.</p><div class="fullcomment"><div class="comment cmt"><p>Creates an Observable which produces windows of collected values. This Observable produces connected
non-overlapping windows. The current window is emitted and replaced with a new window when the
Observable produced by the specified function produces an object.
The function will then be used to create a new Observable to listen for the end of the next
window.
</p></div><dl class="paramcmts block"><dt class="param">closings</dt><dd class="cmt"><p>
           The function which is used to produce an <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> for every window created.
           When this <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> produces an object, the associated window
           is emitted and replaced with a new one.</p></dd><dt>returns</dt><dd class="cmt"><p>
        An <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> which produces connected non-overlapping windows, which are emitted
        when the current <a href="" class="extype" name="rx.lang.scala.Observable">rx.lang.scala.Observable</a> created with the function argument produces an object.
</p></dd></dl></div>
    </li><li name="rx.lang.scala.Observable#withFilter" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="withFilter(p:T=&gt;Boolean):rx.lang.scala.WithFilter[T]"></a>
      <a id="withFilter((T)⇒Boolean):WithFilter[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFilter</span><span class="params">(<span name="p">p: (<span class="extype" name="rx.lang.scala.Observable.T">T</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="rx.lang.scala.WithFilter">WithFilter</span>[<span class="extype" name="rx.lang.scala.Observable.T">T</span>]</span>
      </span>
      </h4>
      
    </li><li name="rx.lang.scala.Observable#zip" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zip[U](that:rx.lang.scala.Observable[U]):rx.lang.scala.Observable[(T,U)]"></a>
      <a id="zip[U](Observable[U]):Observable[(T,U)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zip</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="that">that: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[<span class="extype" name="rx.lang.scala.Observable.zip.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.Observable.T">T</span>, <span class="extype" name="rx.lang.scala.Observable.zip.U">U</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an Observable formed from this Observable and another Observable by combining
corresponding elements in pairs.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable formed from this Observable and another Observable by combining
corresponding elements in pairs.
The number of <code>onNext</code> invocations of the resulting <code>Observable[(T, U)]</code>
is the minumum of the number of <code>onNext</code> invocations of <code>this</code> and <code>that</code>.
</p></div></div>
    </li><li name="rx.lang.scala.Observable#zipWithIndex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zipWithIndex:rx.lang.scala.Observable[(T,Int)]"></a>
      <a id="zipWithIndex:Observable[(T,Int)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zipWithIndex</span><span class="result">: <a href="" class="extype" name="rx.lang.scala.Observable">Observable</a>[(<span class="extype" name="rx.lang.scala.Observable.T">T</span>, <span class="extype" name="scala.Int">Int</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Zips this Observable with its indices.</p><div class="fullcomment"><div class="comment cmt"><p>Zips this Observable with its indices.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An Observable emitting pairs consisting of all elements of this Observable paired with
        their index. Indices start at 0.
</p></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../lib/template.js"></script>
    </body>
      </html>